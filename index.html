<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Fxp&#39;Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Fxp&#39;Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Fxp&#39;Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fxp">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Fxp'Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Fxp&#39;Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-深挖进程通信" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/15/%E6%B7%B1%E6%8C%96%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" class="article-date">
  <time class="dt-published" datetime="2025-09-15T15:07:06.000Z" itemprop="datePublished">2025-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/15/%E6%B7%B1%E6%8C%96%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/">深挖进程通信</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h1><h2 id="为什么进程之间可以通信？"><a href="#为什么进程之间可以通信？" class="headerlink" title="为什么进程之间可以通信？"></a>为什么进程之间可以通信？</h2><p>尽管用户进程空间有多个，但是内核空间只有一个，所有用户空间可以通过系统调用与内核空间交互，所以用户进程之间可以通过内核空间作为桥梁进行交互。</p>
<p>Linux 设置了两级保护机制：  </p>
<ul>
<li>0 级可由内核调用  </li>
<li>3 级可由用户调用</li>
</ul>
<p>进程空间通常为 3GB，最高的 1G 虚拟内存空间为所有进程和内核所共享。总的来说，内核就像中央控制室，一个进程可以将信息发给内核，另一个进程再从内核获得，以实现进程间通信。</p>
<h2 id="通信机制分类"><a href="#通信机制分类" class="headerlink" title="通信机制分类"></a>通信机制分类</h2><p>从机制上划分，进程间通信分为 <strong>共享内存式</strong> 和 <strong>消息传递式</strong>：</p>
<ul>
<li><p><strong>共享内存式</strong><br>通信中枢建立好通信信道后，通信双方之后的通信不需要通信中枢的协助。也正因如此，通信双方需要保证进程间同步，以保证数据读写的一致性，属于对称式的通信，双方平等在共享内存上进行通信。  </p>
</li>
<li><p><strong>消息传递式</strong><br>通信中枢建立好通信信道后，每次通信还都需要通信中枢的协助。  </p>
<ul>
<li><strong>无边界消息</strong>：是字节流，发过来是一个一个的字节，要靠进程自己设计如何区分消息的边界。  </li>
<li><strong>有边界消息</strong>：发送和接收都是以消息为基本单位，类似于一封封完整的信件，接收方可以明确地知道每个消息的开始和结束位置，属于非对称式通信，比如客户端向服务端发起请求，服务端处理好后发回客户端。</li>
</ul>
</li>
</ul>
<h2 id="通信接口需求"><a href="#通信接口需求" class="headerlink" title="通信接口需求"></a>通信接口需求</h2><p>实现进程间通信需要实现三类接口：  </p>
<ol>
<li><strong>如何建立通信信道</strong>：对于非对称的通信，一般由服务端或者消费者建立信道，客户端或者生产者加入信道。  </li>
<li><strong>如何找到并加入通信信道</strong>：一般是双方通过约定好的信道名字找到信道句柄，通过句柄加入通信信道。  </li>
<li><strong>如何使用通信信道</strong>：一般跟对文件句柄的操作差不多。</li>
</ol>
<hr>
<h2 id="常见的-IPC-方式"><a href="#常见的-IPC-方式" class="headerlink" title="常见的 IPC 方式"></a>常见的 IPC 方式</h2><h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h3><p>管道又分为 <strong>匿名管道</strong> 和 <strong>有名管道</strong>。</p>
<ul>
<li><p><strong>匿名管道</strong>  </p>
<ul>
<li>没有名字，是一种临时存放在内存中的单向数据通道，主要用于有关系的父子进程之间。  </li>
<li>工作原理基于文件描述符：一个进程调用 <code>pipe</code> 函数创建匿名管道时，会得到两个文件描述符，<code>fd[0]</code> 用于读，<code>fd[1]</code> 用于写。  </li>
<li>父子进程通过继承的文件描述符实现通信。  </li>
<li><strong>优点</strong>：实现简单，效率高，基于内存，速度快。  </li>
<li><strong>缺点</strong>：半双工，只能单向通信；仅限亲缘关系进程；缓冲区有限。</li>
</ul>
</li>
<li><p><strong>有名管道（FIFO）</strong>  </p>
<ul>
<li>在文件系统中有一个名字，可以用在没有亲缘关系的进程之间。  </li>
<li>使用 <code>mkfifo(&quot;myfifo&quot;, 0666)</code> 创建。  </li>
<li><strong>优点</strong>：可在任意进程间通信，生命周期独立于进程。  </li>
<li><strong>缺点</strong>：仍是半双工；需要文件系统操作，开销更大。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-信号"><a href="#2-信号" class="headerlink" title="2. 信号"></a>2. 信号</h3><ul>
<li>一种 <strong>异步事件通知机制</strong>。  </li>
<li>示例：按下 <code>Ctrl + C</code> → 内核向前台进程发送 <code>SIGINT</code> → 默认终止运行。  </li>
<li>进程处理信号的三种方式：  <ol>
<li>执行默认动作  </li>
<li>忽略信号  </li>
<li>自定义信号处理函数</li>
</ol>
</li>
<li><strong>优点</strong>：简单高效，能快速通知事件发生。  </li>
<li><strong>缺点</strong>：信息量有限，仅有信号编号；执行时机不确定，可能造成竞态问题。</li>
</ul>
<hr>
<h3 id="3-文件"><a href="#3-文件" class="headerlink" title="3. 文件"></a>3. 文件</h3><ul>
<li>原理：不同进程通过 <strong>读写同一文件</strong> 实现数据共享。  </li>
<li>场景：日志系统、配置文件共享。  </li>
<li>问题：并发写入会导致数据覆盖和一致性问题。  </li>
<li>解决办法：使用 <strong>文件锁</strong>（共享锁 &#x2F; 排他锁）。</li>
</ul>
<hr>
<h3 id="4-共享内存"><a href="#4-共享内存" class="headerlink" title="4. 共享内存"></a>4. 共享内存</h3><ul>
<li>允许多个进程访问同一内存区域，是一种高效的 IPC 机制。  </li>
<li>常用函数：<code>shmget</code>、<code>shmat</code>、<code>shmdt</code>、<code>shmctl</code>。</li>
</ul>
<hr>
<h3 id="5-消息队列"><a href="#5-消息队列" class="headerlink" title="5. 消息队列"></a>5. 消息队列</h3><ul>
<li>类似一个存放消息的“信箱”。  </li>
<li>本质：链表结构，每个节点存储一条消息（类型 + 内容）。  </li>
<li>特点：  <ul>
<li><strong>异步通信</strong>，发送方不必等待接收方。  </li>
<li><strong>解耦</strong>：进程只需关心消息队列，不直接依赖对方。</li>
</ul>
</li>
<li>应用：分布式系统中的任务请求和结果响应。</li>
</ul>
<hr>
<h3 id="6-Socket-通信"><a href="#6-Socket-通信" class="headerlink" title="6. Socket 通信"></a>6. Socket 通信</h3><ul>
<li>一种 <strong>网络通信形式</strong>。  </li>
<li>可用于 <strong>本地进程通信</strong>，也可用于 <strong>远程进程通信</strong>。</li>
</ul>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/15/%E6%B7%B1%E6%8C%96%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" data-id="cmfmovbe50000lapv4zdk5yck" data-title="深挖进程通信" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IPC%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" rel="tag">IPC，进程通信</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-AI编程提示词技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/14/AI%E7%BC%96%E7%A8%8B%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2025-09-14T15:32:46.000Z" itemprop="datePublished">2025-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/14/AI%E7%BC%96%E7%A8%8B%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8A%80%E5%B7%A7/">AI编程提示词技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-需求模糊，思维模糊，想法模糊时"><a href="#1-需求模糊，思维模糊，想法模糊时" class="headerlink" title="1. 需求模糊，思维模糊，想法模糊时"></a>1. 需求模糊，思维模糊，想法模糊时</h2><p>当需求不清晰时，直接向 AI 坦白，提供核心功能诉求，明确需要什么类型的帮助或方案设计。  </p>
<p><strong>示例提示词：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我有一个模糊的想法：想做一个「&#123;产品/功能简述&#125;」。目前只确定核心目标是「&#123;核心目标&#125;」。请：</span><br><span class="line">1) 列出 4–6 种可行的实现方向；</span><br><span class="line">2) 每种方向写出关键技术与适用场景；</span><br><span class="line">3) 给出下一步必须澄清的 8 个问题。</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">```text</span><br><span class="line">场景：我要做一个能在手机上离线识别中文的模型，但不确定用轻量模型还是服务器推理。请帮我做决策矩阵：</span><br><span class="line">- 比较项：准确率、延迟、开发成本、部署复杂度、可维护性</span><br><span class="line">- 给出推荐方案，并写出 3 个实验思路。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-锁定范围，聚焦优化"><a href="#2-锁定范围，聚焦优化" class="headerlink" title="2. 锁定范围，聚焦优化"></a>2. 锁定范围，聚焦优化</h2><p>在优化代码时，提供当前状态作为基准点，列出明确的优化方向和具体需求，设定约束条件，让 AI 明白是在<strong>现有基础上优化</strong>。</p>
<p><strong>示例提示词：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是当前基线：</span><br><span class="line">- QPS=&#123;qps&#125;，p95=&#123;p95&#125;ms，内存=&#123;mem&#125;MB</span><br><span class="line">目标：把 p95 降低到 ≤ &#123;目标&#125;ms，要求不改架构。请给出 3 个优化方案（含改动点、预期效果、风险与回滚步骤）。</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我只允许在以下约束内优化：不能引入外部依赖；只能修改 &#123;模块名&#125;。请做代码审查式优化建议，输出格式：</span><br><span class="line">- 问题点</span><br><span class="line">- 建议修改</span><br><span class="line">- 预期效果</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-让-AI-扮演专家角色"><a href="#3-让-AI-扮演专家角色" class="headerlink" title="3. 让 AI 扮演专家角色"></a>3. 让 AI 扮演专家角色</h2><p>明确让 AI 扮演某类专家，从专业角度主动提出优化方案。</p>
<p><strong>示例提示词：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你现在是一个有 10 年经验的 Go 性能优化专家，请审查下面代码，并给出：</span><br><span class="line">1) 关键性能瓶颈（含依据）</span><br><span class="line">2) 改进代码示例</span><br><span class="line">3) 验证方法与预期提升幅度</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你是分布式数据库架构师。系统写入量每小时 &#123;写入量&#125;，请基于 CAP、可用性、延迟权衡，给出两种架构方案并比较。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-正向激励，设定高期望与高优先级"><a href="#4-正向激励，设定高期望与高优先级" class="headerlink" title="4. 正向激励，设定高期望与高优先级"></a>4. 正向激励，设定高期望与高优先级</h2><p>通过设定目标与优先级，调用 AI 的积极性。</p>
<p><strong>示例提示词：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优先级：性能 &gt; 正确性 &gt; 可读性。</span><br><span class="line">目标：p99 延迟从 &#123;old&#125;ms 降到 &#123;target&#125;ms。</span><br><span class="line">请输出：必须做（高）、建议做（中）、可选（低）的改进清单，并为必须做项写出实施计划。</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个紧急修复：用户可见的崩溃。请先给出临时修复措施（最少代码改动），再给出长期根因修复建议。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-在必要时及时补充上下文"><a href="#5-在必要时及时补充上下文" class="headerlink" title="5. 在必要时及时补充上下文"></a>5. 在必要时及时补充上下文</h2><p>补充环境、日志、错误堆栈等上下文，避免信息差。</p>
<p><strong>示例提示词：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我将提供上下文：</span><br><span class="line">- 环境：OS=&#123;os&#125;，语言/版本=&#123;ver&#125;，依赖版本=&#123;deps&#125;</span><br><span class="line">- 复现步骤：&#123;步骤&#125;</span><br><span class="line">- 日志/错误堆栈：&#123;日志&#125;</span><br><span class="line">- 期望行为 vs 实际行为</span><br><span class="line"></span><br><span class="line">请先列出你还需要的额外信息（最多 6 条），再基于现有上下文做 3 个可能原因分析和修复方案。</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给出数据库问题时，我会提供表结构、索引、执行计划、慢查询样本。请写出索引建议、SQL 重写示例，以及预计 IO 改善说明。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-分阶段设计"><a href="#6-分阶段设计" class="headerlink" title="6. 分阶段设计"></a>6. 分阶段设计</h2><p>采用「需求澄清 → 思路设计 → 方案输出 → 优化改进」的流程，避免信息一次过载。</p>
<p><strong>示例提示词：</strong></p>
<p><strong>Phase 1 — 需求澄清</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请以产品经理的角度，提出 10 个问题帮助澄清需求。每个问题后加一句说明：为什么问这个问题。</span><br></pre></td></tr></table></figure>

<p><strong>Phase 2 — 思路设计</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于回答，给出 3 个可行方案（含优缺点、适用场景、关键风险）。</span><br></pre></td></tr></table></figure>

<p><strong>Phase 3 — 方案输出</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选定方案 A，输出：</span><br><span class="line">- 实现步骤（分里程碑）</span><br><span class="line">- 核心伪代码</span><br><span class="line">- 单元测试用例示例</span><br><span class="line">- 部署与回滚流程</span><br></pre></td></tr></table></figure>

<p><strong>Phase 4 — 优化改进</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现后，请给出 6 条优化建议（性能、可观测性、容错、可维护性、安全），并附量化指标和验证方法。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/14/AI%E7%BC%96%E7%A8%8B%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8A%80%E5%B7%A7/" data-id="cmfjv6ylw0000appvb7dn96x3" data-title="AI编程提示词技巧" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ai/" rel="tag">ai</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8F%90%E6%95%88/" rel="tag">提效</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-岛屿数量" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/" class="article-date">
  <time class="dt-published" datetime="2025-09-14T13:28:08.000Z" itemprop="datePublished">2025-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/">岛屿数量</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本题为力扣 <strong>200. 岛屿数量</strong>：<br>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1：<br>输入：grid &#x3D; [<br>  [‘1’,’1’,’1’,’1’,’0’],<br>  [‘1’,’1’,’0’,’1’,’0’],<br>  [‘1’,’1’,’0’,’0’,’0’],<br>  [‘0’,’0’,’0’,’0’,’0’]<br>]<br>输出：1</p>
<p>示例 2：<br>输入：grid &#x3D; [<br>  [‘1’,’1’,’0’,’0’,’0’],<br>  [‘1’,’1’,’0’,’0’,’0’],<br>  [‘0’,’0’,’1’,’0’,’0’],<br>  [‘0’,’0’,’0’,’1’,’1’]<br>]<br>输出：3</p>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li><p>图论问题通常就是对者一个矩阵大做文章，比如检查连通性，找路径等等。而且经常涉及遍历图，通常用DFS和BFS。</p>
</li>
<li><p>岛屿就是联通的1，所以可以对点进行平均两次遍历，第一次遍历，如果当前格子为0或者越界，则返回，如果为1，则置零，并且向四个方向进行递归dfs。确保每一个联通的岛屿只计数1次</p>
</li>
</ol>
<hr>
<h2 id="代码实现（Go）"><a href="#代码实现（Go）" class="headerlink" title="代码实现（Go）"></a>代码实现（Go）</h2><pre><code class="language-go">func numIslands(grid [][]byte) int &#123;
    if len(grid) == 0 &#123;
        return 0
    &#125;

    rows, cols := len(grid), len(grid[0])
    var dfs func(r, c int)

    dfs = func(r, c int) &#123;
        // 边界条件
        if r &lt; 0 || c &lt; 0 || r &gt;= rows || c &gt;= cols || grid[r][c] == &#39;0&#39; &#123;
            return
        &#125;
        // 标记为水，表示访问过
        grid[r][c] = &#39;0&#39;

        // 上下左右四个方向
        dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)
    &#125;

    count := 0
    for i := 0; i &lt; rows; i++ &#123;
        for j := 0; j &lt; cols; j++ &#123;
            if grid[i][j] == &#39;1&#39; &#123;
                count++
                dfs(i, j) // 把这个岛屿淹掉
            &#125;
        &#125;
    &#125;
    return count
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/" data-id="cmfjro7vo00002dpvayoja7zr" data-title="岛屿数量" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%88%B7%E9%A2%98%EF%BC%8C%E5%9B%BE%E8%AE%BA%EF%BC%8CDFS/" rel="tag">算法，刷题，图论，DFS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-路径总和" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/11/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/" class="article-date">
  <time class="dt-published" datetime="2025-09-11T14:14:45.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/11/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/">路径总和</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本题为力扣 <strong>437. 路径总和 Ⅲ</strong>：<br>给定一个二叉树的根节点 <code>root</code>，和一个整数 <code>targetSum</code>，求该二叉树里节点值之和等于 <code>targetSum</code> 的路径数目。  </p>
<p>路径 <strong>不需要从根节点开始</strong>，也不需要在叶子节点结束，但必须是 <strong>向下的路径</strong>（从父节点到子节点）。</p>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li><p><strong>递归与状态传递</strong><br>在递归类的题目中，几乎都涉及到 <strong>状态的传递</strong>，即当前递归位置所带的信息。  </p>
<ul>
<li>在树里：当前节点是谁？  </li>
<li>在路径题里：当前走到的路径和是多少？  </li>
<li>在组合题里：当前选了哪些数？  </li>
<li>在动态规划里：当前下标、剩余容量、剩余步数？</li>
</ul>
<p>👉 没有这些状态，就无法确定接下来该怎么走。  </p>
<p>在本题中，需要传递的状态是：<strong>经过当前节点后，距离 <code>targetSum</code> 还差多少</strong>。  </p>
<p>同时，递归的返回值也非常重要。通常返回的就是「符合条件的个数」等信息，因为只有返回值才能逐层汇总答案。  </p>
</li>
<li><p><strong>递归结束条件</strong><br>当遍历到空节点时，递归应当结束，返回 0。</p>
</li>
</ol>
<hr>
<h2 id="代码实现（Go）"><a href="#代码实现（Go）" class="headerlink" title="代码实现（Go）"></a>代码实现（Go）</h2><pre><code class="language-go">func pathSum(root *TreeNode, targetSum int) int &#123;
    if root == nil &#123;
        return 0
    &#125;
    return countPath(root, targetSum) + pathSum(root.Left, targetSum) + pathSum(root.Right, targetSum)
&#125;

// 统计以 node 为起点，向下路径和等于 targetSum 的数量
func countPath(node *TreeNode, targetSum int) int &#123;
    if node == nil &#123;
        return 0
    &#125;
    count := 0
    if node.Val == targetSum &#123;
        count++
    &#125;
    count += countPath(node.Left, targetSum-node.Val)
    count += countPath(node.Right, targetSum-node.Val)
    return count
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/11/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/" data-id="cmfjgku960000gcpv6isdc7kc" data-title="路径总和" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-k8s深入理解" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/10/k8s%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/" class="article-date">
  <time class="dt-published" datetime="2025-09-10T15:37:43.000Z" itemprop="datePublished">2025-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/10/k8s%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/">k8s深入理解</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Kubernetes深度学习总结：从概念到实践"><a href="#Kubernetes深度学习总结：从概念到实践" class="headerlink" title="Kubernetes深度学习总结：从概念到实践"></a>Kubernetes深度学习总结：从概念到实践</h1><blockquote>
<p>基于Raft KV分布式系统项目的Kubernetes学习之路</p>
</blockquote>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol>
<li><a href="#1-%E5%88%9D%E8%AF%86kubernetes%E8%A7%A3%E5%86%B3%E8%AE%A4%E7%9F%A5%E5%9B%B0%E6%83%91">初识Kubernetes：解决认知困惑</a></li>
<li><a href="#2-kubernetes%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%AE%9A%E4%BD%8D">Kubernetes的本质定位</a></li>
<li><a href="#3-pod%E6%9C%80%E5%B0%8F%E9%83%A8%E7%BD%B2%E5%8D%95%E5%85%83%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3">Pod：最小部署单元的深度理解</a></li>
<li><a href="#4-kubernetes%E5%9C%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%AE%9E%E9%99%85%E9%83%A8%E7%BD%B2">Kubernetes在操作系统中的实际部署</a></li>
<li><a href="#5-pod%E8%B0%83%E5%BA%A6%E5%88%B0%E7%89%A9%E7%90%86%E8%8A%82%E7%82%B9%E7%9A%84%E5%AE%8C%E6%95%B4%E6%9C%BA%E5%88%B6">Pod调度到物理节点的完整机制</a></li>
<li><a href="#6-pod%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E7%9A%84%E9%BB%91%E7%AE%B1%E6%8F%AD%E7%A7%98">Pod创建和管理的黑箱揭秘</a></li>
<li><a href="#7-%E5%BA%94%E7%94%A8%E5%86%85%E9%83%A8%E5%88%9B%E5%BB%BApod%E7%9A%84%E5%A5%97%E5%A8%83%E7%8E%B0%E8%B1%A1">应用内部创建Pod的”套娃”现象</a></li>
<li><a href="#8-kubernetes%E8%BF%90%E8%A1%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97">Kubernetes运行进程的完整操作指南</a></li>
<li><a href="#9-pod%E5%AE%B9%E5%99%A8%E6%95%B0%E9%87%8F%E7%9A%84%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6">Pod容器数量的控制机制</a></li>
<li><a href="#10-%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">实践总结与最佳实践</a></li>
</ol>
<hr>
<h2 id="1-初识Kubernetes：解决认知困惑"><a href="#1-初识Kubernetes：解决认知困惑" class="headerlink" title="1. 初识Kubernetes：解决认知困惑"></a>1. 初识Kubernetes：解决认知困惑</h2><h3 id="1-1-问题的起源"><a href="#1-1-问题的起源" class="headerlink" title="1.1 问题的起源"></a>1.1 问题的起源</h3><p>作为一个接触Kubernetes的新手，最大的困惑来自于：</p>
<ul>
<li><strong>侵入性太强</strong>：K8s似乎要改变整个应用的架构</li>
<li><strong>概念抽象</strong>：Pod、Service、Deployment等概念难以理解</li>
<li><strong>黑箱操作</strong>：不知道Pod是如何创建和运行的</li>
</ul>
<h3 id="1-2-认知转变的关键"><a href="#1-2-认知转变的关键" class="headerlink" title="1.2 认知转变的关键"></a>1.2 认知转变的关键</h3><p><strong>核心理解</strong>：Kubernetes不是应用框架，而是基础设施抽象层。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">传统方式: 应用 → 物理机/虚拟机</span><br><span class="line">K8s方式:  应用 → K8s抽象层 → 物理机/虚拟机</span><br></pre></td></tr></table></figure>

<h3 id="1-3-模块化视角下的K8s"><a href="#1-3-模块化视角下的K8s" class="headerlink" title="1.3 模块化视角下的K8s"></a>1.3 模块化视角下的K8s</h3><p>Kubernetes本质上是一个模块化的分布式系统：</p>
<p><strong>控制平面模块</strong>：</p>
<ul>
<li><code>kube-apiserver</code>: API网关</li>
<li><code>etcd</code>: 分布式配置存储</li>
<li><code>kube-scheduler</code>: 资源调度器</li>
<li><code>kube-controller-manager</code>: 状态控制器</li>
</ul>
<p><strong>工作节点模块</strong>：</p>
<ul>
<li><code>kubelet</code>: 节点代理</li>
<li><code>kube-proxy</code>: 网络代理</li>
<li><code>容器运行时</code>: Docker&#x2F;containerd</li>
</ul>
<hr>
<h2 id="2-Kubernetes的本质定位"><a href="#2-Kubernetes的本质定位" class="headerlink" title="2. Kubernetes的本质定位"></a>2. Kubernetes的本质定位</h2><h3 id="2-1-重新定位Kubernetes"><a href="#2-1-重新定位Kubernetes" class="headerlink" title="2.1 重新定位Kubernetes"></a>2.1 重新定位Kubernetes</h3><p><strong>K8s不是什么</strong>：</p>
<ul>
<li>❌ 不是应用开发框架</li>
<li>❌ 不是编程语言</li>
<li>❌ 不是数据库或中间件</li>
</ul>
<p><strong>K8s是什么</strong>：</p>
<ul>
<li>✅ 分布式系统的操作系统</li>
<li>✅ 资源管理和调度平台</li>
<li>✅ 应用生命周期管理工具</li>
</ul>
<h3 id="2-2-抽象层次的理解"><a href="#2-2-抽象层次的理解" class="headerlink" title="2.2 抽象层次的理解"></a>2.2 抽象层次的理解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用层 (你的Raft KV服务)</span><br><span class="line">    ↓</span><br><span class="line">容器层 (Docker容器)</span><br><span class="line">    ↓</span><br><span class="line">K8s编排层 (Pod, Service, Deployment)</span><br><span class="line">    ↓</span><br><span class="line">基础设施层 (物理机/云服务器)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-渐进式理解策略"><a href="#2-3-渐进式理解策略" class="headerlink" title="2.3 渐进式理解策略"></a>2.3 渐进式理解策略</h3><p><strong>第一阶段：容器化（最小侵入）</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> your-app /app/</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/app/your-app&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>第二阶段：单Pod运行</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-app:latest</span></span><br></pre></td></tr></table></figure>

<p><strong>第三阶段：逐步添加K8s特性</strong></p>
<ul>
<li>需要多副本？添加Deployment</li>
<li>需要服务发现？添加Service</li>
<li>需要配置管理？添加ConfigMap</li>
</ul>
<hr>
<h2 id="3-Pod：最小部署单元的深度理解"><a href="#3-Pod：最小部署单元的深度理解" class="headerlink" title="3. Pod：最小部署单元的深度理解"></a>3. Pod：最小部署单元的深度理解</h2><h3 id="3-1-Pod的准确定义"><a href="#3-1-Pod的准确定义" class="headerlink" title="3.1 Pod的准确定义"></a>3.1 Pod的准确定义</h3><p><strong>重要概念</strong>：Pod不是一个容器，而是一个或多个容器的集合！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看Pod内的容器</span></span><br><span class="line">kubectl describe pod my-pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Containers:</span><br><span class="line">  main-app:          <span class="comment"># 主应用容器</span></span><br><span class="line">    Image: my-app:v1.0</span><br><span class="line">  sidecar-proxy:     <span class="comment"># 边车容器</span></span><br><span class="line">    Image: nginx:1.20</span><br><span class="line">  log-collector:     <span class="comment"># 日志收集容器</span></span><br><span class="line">    Image: fluentd:v1.14</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Pod在操作系统中的实际形态"><a href="#3-2-Pod在操作系统中的实际形态" class="headerlink" title="3.2 Pod在操作系统中的实际形态"></a>3.2 Pod在操作系统中的实际形态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">操作系统 (Linux/Windows)</span><br><span class="line">├── Docker/containerd (容器运行时)</span><br><span class="line">│   ├── Pod网络命名空间 (共享网络)</span><br><span class="line">│   │   ├── 容器1: my-app</span><br><span class="line">│   │   ├── 容器2: nginx-proxy  </span><br><span class="line">│   │   └── 容器3: log-collector</span><br><span class="line">│   ├── 共享存储卷</span><br><span class="line">│   └── 共享进程命名空间(可选)</span><br><span class="line">└── kubelet (K8s节点代理)</span><br></pre></td></tr></table></figure>

<h3 id="3-3-“最小部署单元”的准确含义"><a href="#3-3-“最小部署单元”的准确含义" class="headerlink" title="3.3 “最小部署单元”的准确含义"></a>3.3 “最小部署单元”的准确含义</h3><p><strong>关键理解</strong>：</p>
<ul>
<li>✅ Pod是K8s中最小的<strong>可部署</strong>和<strong>可管理</strong>的单元</li>
<li>✅ 你不能直接部署单个容器到K8s，必须通过Pod</li>
<li>✅ K8s的所有操作（调度、扩缩容、重启等）都是以Pod为单位</li>
<li>❌ Pod不是最小的<strong>运行</strong>单元（容器才是）</li>
</ul>
<h3 id="3-4-实际验证Pod的容器组成"><a href="#3-4-实际验证Pod的容器组成" class="headerlink" title="3.4 实际验证Pod的容器组成"></a>3.4 实际验证Pod的容器组成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在运行的系统上查看</span></span><br><span class="line">docker ps | grep k8s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例（一个Pod对应多个容器）：</span></span><br><span class="line">CONTAINER ID   IMAGE                    NAMES</span><br><span class="line">1a2b3c4d5e6f   my-app:v1.0             k8s_main-app_my-pod_default_uuid</span><br><span class="line">2b3c4d5e6f7g   nginx:1.20              k8s_proxy_my-pod_default_uuid</span><br><span class="line">3c4d5e6f7g8h   pause:3.6               k8s_POD_my-pod_default_uuid</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>pause</code>容器是Pod的基础设施容器，负责维护网络和存储命名空间。</p>
<hr>
<h2 id="4-Kubernetes在操作系统中的实际部署"><a href="#4-Kubernetes在操作系统中的实际部署" class="headerlink" title="4. Kubernetes在操作系统中的实际部署"></a>4. Kubernetes在操作系统中的实际部署</h2><h3 id="4-1-单机部署：All-in-One模式"><a href="#4-1-单机部署：All-in-One模式" class="headerlink" title="4.1 单机部署：All-in-One模式"></a>4.1 单机部署：All-in-One模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">一台物理机/虚拟机</span><br><span class="line">├── 控制平面组件 (Master Components)</span><br><span class="line">│   ├── kube-apiserver     (端口: 6443)</span><br><span class="line">│   ├── etcd              (端口: 2379, 2380)</span><br><span class="line">│   ├── kube-scheduler    (调度器)</span><br><span class="line">│   └── kube-controller-manager (控制器)</span><br><span class="line">├── 工作节点组件 (Worker Components)</span><br><span class="line">│   ├── kubelet           (节点代理)</span><br><span class="line">│   ├── kube-proxy        (网络代理)</span><br><span class="line">│   └── 容器运行时 (Docker/containerd)</span><br><span class="line">└── 网络插件 (CNI)</span><br><span class="line">    ├── flannel/calico/weave</span><br><span class="line">    └── 虚拟网桥和路由</span><br></pre></td></tr></table></figure>

<h3 id="4-2-实际进程验证"><a href="#4-2-实际进程验证" class="headerlink" title="4.2 实际进程验证"></a>4.2 实际进程验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在K8s节点上查看运行的进程</span></span><br><span class="line">ps aux | grep kube</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">root  1234  kube-apiserver --advertise-address=192.168.1.100</span><br><span class="line">root  1235  etcd --data-dir=/var/lib/etcd</span><br><span class="line">root  1236  kube-scheduler --kubeconfig=/etc/kubernetes/scheduler.conf</span><br><span class="line">root  1237  kube-controller-manager --kubeconfig=/etc/kubernetes/controller-manager.conf</span><br><span class="line">root  1238  kubelet --config=/var/lib/kubelet/config.yaml</span><br><span class="line">root  1239  kube-proxy --config=/var/lib/kube-proxy/config.conf</span><br></pre></td></tr></table></figure>

<h3 id="4-3-部署方式详解"><a href="#4-3-部署方式详解" class="headerlink" title="4.3 部署方式详解"></a>4.3 部署方式详解</h3><h4 id="本地开发环境"><a href="#本地开发环境" class="headerlink" title="本地开发环境"></a>本地开发环境</h4><p><strong>Minikube（最简单）</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装并启动</span></span><br><span class="line">minikube start</span><br><span class="line">kubectl cluster-info</span><br></pre></td></tr></table></figure>

<p><strong>Kind（Kubernetes in Docker）</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建集群</span></span><br><span class="line">kind create cluster --name my-cluster</span><br><span class="line"></span><br><span class="line"><span class="comment"># Kind在Docker容器中运行K8s节点</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">CONTAINER ID   IMAGE                  NAMES</span><br><span class="line">1a2b3c4d5e6f   kindest/node:v1.27.3   my-cluster-control-plane</span><br></pre></td></tr></table></figure>

<h4 id="生产环境部署"><a href="#生产环境部署" class="headerlink" title="生产环境部署"></a>生产环境部署</h4><p><strong>kubeadm（官方工具）</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Master节点初始化</span></span><br><span class="line"><span class="built_in">sudo</span> kubeadm init --pod-network-cidr=10.244.0.0/16</span><br><span class="line"></span><br><span class="line"><span class="comment"># Worker节点加入</span></span><br><span class="line"><span class="built_in">sudo</span> kubeadm <span class="built_in">join</span> 192.168.1.100:6443 --token &lt;token&gt; --discovery-token-ca-cert-hash &lt;<span class="built_in">hash</span>&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-Pod调度到物理节点的完整机制"><a href="#5-Pod调度到物理节点的完整机制" class="headerlink" title="5. Pod调度到物理节点的完整机制"></a>5. Pod调度到物理节点的完整机制</h2><h3 id="5-1-Kubernetes集群的物理架构"><a href="#5-1-Kubernetes集群的物理架构" class="headerlink" title="5.1 Kubernetes集群的物理架构"></a>5.1 Kubernetes集群的物理架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Kubernetes集群</span><br><span class="line">├── 控制平面节点 (Master Nodes)</span><br><span class="line">│   ├── kube-apiserver</span><br><span class="line">│   ├── etcd</span><br><span class="line">│   ├── kube-scheduler  ← 负责Pod调度</span><br><span class="line">│   └── kube-controller-manager</span><br><span class="line">└── 工作节点 (Worker Nodes)</span><br><span class="line">    ├── 物理机1 (kubelet + 容器运行时)</span><br><span class="line">    ├── 物理机2 (kubelet + 容器运行时)</span><br><span class="line">    ├── 虚拟机1 (kubelet + 容器运行时)</span><br><span class="line">    └── 虚拟机2 (kubelet + 容器运行时)</span><br></pre></td></tr></table></figure>

<h3 id="5-2-Pod调度的完整流程"><a href="#5-2-Pod调度的完整流程" class="headerlink" title="5.2 Pod调度的完整流程"></a>5.2 Pod调度的完整流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">用户创建Pod</span><br><span class="line">    ↓</span><br><span class="line">API Server接收请求</span><br><span class="line">    ↓</span><br><span class="line">Scheduler分析资源需求</span><br><span class="line">    ↓</span><br><span class="line">筛选可用节点</span><br><span class="line">    ↓</span><br><span class="line">评分排序</span><br><span class="line">    ↓</span><br><span class="line">选择最佳节点</span><br><span class="line">    ↓</span><br><span class="line">kubelet在目标节点创建容器</span><br></pre></td></tr></table></figure>

<h3 id="5-3-实际调度示例"><a href="#5-3-实际调度示例" class="headerlink" title="5.3 实际调度示例"></a>5.3 实际调度示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Pod后查看调度结果</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE   IP           NODE</span><br><span class="line">my-raft-pod   1/1     Running   0          30s   10.244.2.15  worker-node-2</span><br></pre></td></tr></table></figure>

<p>可以看到Pod被调度到了<code>worker-node-2</code>这台实际的机器上！</p>
<h3 id="5-4-节点资源管理"><a href="#5-4-节点资源管理" class="headerlink" title="5.4 节点资源管理"></a>5.4 节点资源管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点详细信息</span></span><br><span class="line">kubectl describe node worker-node-2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">Addresses:</span><br><span class="line">  InternalIP:  192.168.1.102  ← 实际物理机IP</span><br><span class="line">Capacity:</span><br><span class="line">  cpu:                4      ← 4核CPU</span><br><span class="line">  memory:             8Gi    ← 8GB内存</span><br><span class="line">Allocated resources:</span><br><span class="line">  cpu                1500m (39%) </span><br><span class="line">  memory             3Gi (40%)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-Pod创建和管理的黑箱揭秘"><a href="#6-Pod创建和管理的黑箱揭秘" class="headerlink" title="6. Pod创建和管理的黑箱揭秘"></a>6. Pod创建和管理的黑箱揭秘</h2><h3 id="6-1-Pod创建的几种方式"><a href="#6-1-Pod创建的几种方式" class="headerlink" title="6.1 Pod创建的几种方式"></a>6.1 Pod创建的几种方式</h3><h4 id="命令行创建"><a href="#命令行创建" class="headerlink" title="命令行创建"></a>命令行创建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接创建Pod</span></span><br><span class="line">kubectl run my-pod --image=nginx --restart=Never</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过YAML文件创建</span></span><br><span class="line">kubectl apply -f pod.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Job</span></span><br><span class="line">kubectl create job my-job --image=busybox -- <span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="程序化创建（应用内部创建Pod）"><a href="#程序化创建（应用内部创建Pod）" class="headerlink" title="程序化创建（应用内部创建Pod）"></a>程序化创建（应用内部创建Pod）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python K8s客户端</span></span><br><span class="line"><span class="keyword">from</span> kubernetes <span class="keyword">import</span> client, config</span><br><span class="line"></span><br><span class="line">config.load_incluster_config()</span><br><span class="line">v1 = client.CoreV1Api()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Pod</span></span><br><span class="line">response = v1.create_namespaced_pod(</span><br><span class="line">    namespace=<span class="string">&quot;default&quot;</span>,</span><br><span class="line">    body=pod_manifest</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Pod created: <span class="subst">&#123;response.metadata.name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="6-2-如何”拿到”Pod：获取Pod信息的方法"><a href="#6-2-如何”拿到”Pod：获取Pod信息的方法" class="headerlink" title="6.2 如何”拿到”Pod：获取Pod信息的方法"></a>6.2 如何”拿到”Pod：获取Pod信息的方法</h3><h4 id="通过名称直接获取"><a href="#通过名称直接获取" class="headerlink" title="通过名称直接获取"></a>通过名称直接获取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取特定Pod</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pod = v1.read_namespaced_pod(</span><br><span class="line">        name=<span class="string">&quot;my-dynamic-pod&quot;</span>,</span><br><span class="line">        namespace=<span class="string">&quot;default&quot;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Pod状态: <span class="subst">&#123;pod.status.phase&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Pod IP: <span class="subst">&#123;pod.status.pod_ip&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> client.exceptions.ApiException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Pod不存在: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="通过标签选择器获取"><a href="#通过标签选择器获取" class="headerlink" title="通过标签选择器获取"></a>通过标签选择器获取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取带有特定标签的所有Pod</span></span><br><span class="line">pods = v1.list_namespaced_pod(</span><br><span class="line">    namespace=<span class="string">&quot;default&quot;</span>,</span><br><span class="line">    label_selector=<span class="string">&quot;app=my-app,job-type=backup&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pod <span class="keyword">in</span> pods.items:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;找到Pod: <span class="subst">&#123;pod.metadata.name&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;状态: <span class="subst">&#123;pod.status.phase&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="6-3-以Raft-KV项目为例的完整流程"><a href="#6-3-以Raft-KV项目为例的完整流程" class="headerlink" title="6.3 以Raft KV项目为例的完整流程"></a>6.3 以Raft KV项目为例的完整流程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在KvServer中创建备份任务</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KvServer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">scheduleBackup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::string jobName = <span class="string">&quot;raft-backup-&quot;</span> + std::<span class="built_in">to_string</span>(m_me) + <span class="string">&quot;-&quot;</span> + <span class="built_in">getCurrentTimestamp</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Job的YAML配置</span></span><br><span class="line">        std::string jobYaml = <span class="built_in">createBackupJobYaml</span>(jobName, m_me);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 提交到K8s</span></span><br><span class="line">        std::string jobId = <span class="built_in">submitJobToKubernetes</span>(jobYaml);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 保存Job信息，用于后续跟踪</span></span><br><span class="line">        m_activeJobs[jobId] = &#123;</span><br><span class="line">            .name = jobName,</span><br><span class="line">            .type = <span class="string">&quot;backup&quot;</span>,</span><br><span class="line">            .startTime = std::<span class="built_in">time</span>(<span class="literal">nullptr</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动监控线程</span></span><br><span class="line">        <span class="function">std::thread <span class="title">monitorThread</span><span class="params">(&amp;KvServer::monitorJob, <span class="keyword">this</span>, jobId)</span></span>;</span><br><span class="line">        monitorThread.<span class="built_in">detach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-应用内部创建Pod的”套娃”现象"><a href="#7-应用内部创建Pod的”套娃”现象" class="headerlink" title="7. 应用内部创建Pod的”套娃”现象"></a>7. 应用内部创建Pod的”套娃”现象</h2><h3 id="7-1-典型场景分析"><a href="#7-1-典型场景分析" class="headerlink" title="7.1 典型场景分析"></a>7.1 典型场景分析</h3><h4 id="CI-CD平台（如Jenkins、GitLab-CI）"><a href="#CI-CD平台（如Jenkins、GitLab-CI）" class="headerlink" title="CI&#x2F;CD平台（如Jenkins、GitLab CI）"></a>CI&#x2F;CD平台（如Jenkins、GitLab CI）</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Jenkins Master运行在K8s中</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jenkins-master</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">jenkins</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">jenkins/jenkins:lts</span></span><br></pre></td></tr></table></figure>

<p>当有构建任务时，Jenkins会动态创建Pod来执行具体的构建工作：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Jenkins动态创建的构建Pod</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">build-job-12345</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">builder</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">maven:3.8-openjdk-11</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;mvn&quot;</span>, <span class="string">&quot;clean&quot;</span>, <span class="string">&quot;package&quot;</span>]</span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-为什么要这样设计？"><a href="#7-2-为什么要这样设计？" class="headerlink" title="7.2 为什么要这样设计？"></a>7.2 为什么要这样设计？</h3><h4 id="资源隔离"><a href="#资源隔离" class="headerlink" title="资源隔离"></a>资源隔离</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">主应用Pod (常驻):</span><br><span class="line">- 内存: 512Mi</span><br><span class="line">- CPU: 0.5 core</span><br><span class="line">- 职责: 调度、监控、API服务</span><br><span class="line"></span><br><span class="line">任务执行Pod (临时):</span><br><span class="line">- 内存: 4Gi</span><br><span class="line">- CPU: 2 cores  </span><br><span class="line">- 职责: 执行具体的计算任务</span><br></pre></td></tr></table></figure>

<h4 id="故障隔离"><a href="#故障隔离" class="headerlink" title="故障隔离"></a>故障隔离</h4><ul>
<li>主应用崩溃 ≠ 所有任务失败</li>
<li>单个任务失败 ≠ 主应用受影响</li>
<li>任务可以独立重试、扩缩容</li>
</ul>
<h3 id="7-3-实际的调度示例"><a href="#7-3-实际的调度示例" class="headerlink" title="7.3 实际的调度示例"></a>7.3 实际的调度示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Pod后查看调度结果</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可能的输出：</span></span><br><span class="line">NAME                READY   STATUS    NODE</span><br><span class="line">raft-kv-cluster-0   1/1     Running   worker-node-1  <span class="comment"># 物理机1</span></span><br><span class="line">raft-kv-cluster-1   1/1     Running   worker-node-2  <span class="comment"># 物理机2</span></span><br><span class="line">raft-kv-cluster-2   1/1     Running   worker-node-3  <span class="comment"># 物理机3</span></span><br><span class="line">raft-kv-cluster-3   1/1     Running   worker-node-1  <span class="comment"># 物理机1</span></span><br><span class="line">raft-kv-cluster-4   1/1     Running   worker-node-2  <span class="comment"># 物理机2</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-Kubernetes运行进程的完整操作指南"><a href="#8-Kubernetes运行进程的完整操作指南" class="headerlink" title="8. Kubernetes运行进程的完整操作指南"></a>8. Kubernetes运行进程的完整操作指南</h2><h3 id="8-1-进程创建操作"><a href="#8-1-进程创建操作" class="headerlink" title="8.1 进程创建操作"></a>8.1 进程创建操作</h3><h4 id="直接创建Pod"><a href="#直接创建Pod" class="headerlink" title="直接创建Pod"></a>直接创建Pod</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令行创建</span></span><br><span class="line">kubectl run my-pod --image=nginx --restart=Never</span><br><span class="line"></span><br><span class="line"><span class="comment"># YAML文件创建</span></span><br><span class="line">kubectl apply -f pod.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式创建</span></span><br><span class="line">kubectl run debug-pod --image=busybox -it --<span class="built_in">rm</span> -- /bin/sh</span><br></pre></td></tr></table></figure>

<h4 id="通过工作负载创建"><a href="#通过工作负载创建" class="headerlink" title="通过工作负载创建"></a>通过工作负载创建</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Deployment（管理多个Pod副本）</span></span><br><span class="line">kubectl create deployment my-app --image=my-app:v1.0 --replicas=3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Job（一次性任务）</span></span><br><span class="line">kubectl create job backup-job --image=backup-tool -- /backup.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建CronJob（定时任务）</span></span><br><span class="line">kubectl create cronjob daily-backup --image=backup-tool --schedule=<span class="string">&quot;0 2 * * *&quot;</span> -- /backup.sh</span><br></pre></td></tr></table></figure>

<h3 id="8-2-进程查询操作"><a href="#8-2-进程查询操作" class="headerlink" title="8.2 进程查询操作"></a>8.2 进程查询操作</h3><h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有Pod</span></span><br><span class="line">kubectl get pods</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定命名空间的Pod</span></span><br><span class="line">kubectl get pods -n my-namespace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 详细信息查看</span></span><br><span class="line">kubectl get pods -o wide</span><br><span class="line">kubectl describe pod my-pod</span><br></pre></td></tr></table></figure>

<h4 id="标签和选择器查询"><a href="#标签和选择器查询" class="headerlink" title="标签和选择器查询"></a>标签和选择器查询</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按标签查询</span></span><br><span class="line">kubectl get pods -l app=my-app</span><br><span class="line">kubectl get pods -l <span class="string">&#x27;environment in (prod,staging)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 按字段选择器查询</span></span><br><span class="line">kubectl get pods --field-selector=status.phase=Running</span><br><span class="line">kubectl get pods --field-selector=spec.nodeName=worker-node-1</span><br></pre></td></tr></table></figure>

<h3 id="8-3-进程监控操作"><a href="#8-3-进程监控操作" class="headerlink" title="8.3 进程监控操作"></a>8.3 进程监控操作</h3><h4 id="状态监控"><a href="#状态监控" class="headerlink" title="状态监控"></a>状态监控</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时监控Pod状态变化</span></span><br><span class="line">kubectl get pods -w</span><br><span class="line">kubectl get pods -l app=my-app -w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Pod事件</span></span><br><span class="line">kubectl get events --sort-by=.metadata.creationTimestamp</span><br></pre></td></tr></table></figure>

<h4 id="资源使用监控"><a href="#资源使用监控" class="headerlink" title="资源使用监控"></a>资源使用监控</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看资源使用情况（需要metrics-server）</span></span><br><span class="line">kubectl top pods</span><br><span class="line">kubectl top nodes</span><br></pre></td></tr></table></figure>

<h3 id="8-4-进程日志操作"><a href="#8-4-进程日志操作" class="headerlink" title="8.4 进程日志操作"></a>8.4 进程日志操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看Pod日志</span></span><br><span class="line">kubectl logs my-pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时跟踪日志</span></span><br><span class="line">kubectl logs -f my-pod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最近的日志</span></span><br><span class="line">kubectl logs my-pod --<span class="built_in">tail</span>=100</span><br><span class="line">kubectl logs my-pod --since=1h</span><br></pre></td></tr></table></figure>

<h3 id="8-5-进程交互操作"><a href="#8-5-进程交互操作" class="headerlink" title="8.5 进程交互操作"></a>8.5 进程交互操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在运行的Pod中执行命令</span></span><br><span class="line">kubectl <span class="built_in">exec</span> my-pod -- <span class="built_in">ls</span> /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式进入容器</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-pod -- /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口转发</span></span><br><span class="line">kubectl port-forward my-pod 8080:80</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-Pod容器数量的控制机制"><a href="#9-Pod容器数量的控制机制" class="headerlink" title="9. Pod容器数量的控制机制"></a>9. Pod容器数量的控制机制</h2><h3 id="9-1-单容器Pod（最常见，90-的场景）"><a href="#9-1-单容器Pod（最常见，90-的场景）" class="headerlink" title="9.1 单容器Pod（最常见，90%+的场景）"></a>9.1 单容器Pod（最常见，90%+的场景）</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">simple-web-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-server</span>    <span class="comment"># 只有一个容器</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.20</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>一个Pod &#x3D; 一个应用容器 + 一个pause容器（基础设施）</li>
<li>这是最简单、最常用的模式</li>
<li>大多数微服务都采用这种模式</li>
</ul>
<h3 id="9-2-多容器Pod（特殊场景，"><a href="#9-2-多容器Pod（特殊场景，" class="headerlink" title="9.2 多容器Pod（特殊场景，&lt;10%）"></a>9.2 多容器Pod（特殊场景，&lt;10%）</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">multi-container-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-app</span>           <span class="comment"># 主应用容器</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-web-app:v1.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shared-logs</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-collector</span>     <span class="comment"># 日志收集容器</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">fluentd:v1.14</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shared-logs</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">metrics-exporter</span>  <span class="comment"># 监控指标容器</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prometheus-exporter:v1.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9090</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">shared-logs</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-实际验证容器数量"><a href="#9-3-实际验证容器数量" class="headerlink" title="9.3 实际验证容器数量"></a>9.3 实际验证容器数量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建单容器Pod</span></span><br><span class="line">kubectl run simple-app --image=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看实际运行的容器</span></span><br><span class="line">docker ps | grep simple-app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  NAMES</span><br><span class="line">1a2b3c4d5e6f   nginx     <span class="string">&quot;nginx -g &#x27;daemon of…&quot;</span>   k8s_simple-app_simple-app_default_uuid</span><br><span class="line">2b3c4d5e6f7g   pause:3.6 <span class="string">&quot;/pause&quot;</span>                 k8s_POD_simple-app_default_uuid</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：</p>
<ul>
<li><code>k8s_simple-app_...</code> 是你的应用容器</li>
<li><code>k8s_POD_...</code> 是pause容器（Pod基础设施）</li>
<li>所以”一个Pod”实际上总是至少有2个容器！</li>
</ul>
<h3 id="9-4-容器数量的设计决策"><a href="#9-4-容器数量的设计决策" class="headerlink" title="9.4 容器数量的设计决策"></a>9.4 容器数量的设计决策</h3><h4 id="何时使用单容器Pod"><a href="#何时使用单容器Pod" class="headerlink" title="何时使用单容器Pod"></a>何时使用单容器Pod</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 典型场景：独立的微服务</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">user-service</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">user-service:v2.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：</p>
<ul>
<li>独立的微服务</li>
<li>无状态应用</li>
<li>简单的批处理任务</li>
<li>大部分Web应用</li>
</ul>
<h4 id="何时使用多容器Pod"><a href="#何时使用多容器Pod" class="headerlink" title="何时使用多容器Pod"></a>何时使用多容器Pod</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 典型场景：Web服务器 + SSL终止代理</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web-app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-app:v1.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br><span class="line">  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ssl-proxy</span>     <span class="comment"># SSL终止和反向代理</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.20</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p><strong>适用场景</strong>：</p>
<ul>
<li>需要边车模式（Sidecar Pattern）</li>
<li>日志收集和监控</li>
<li>代理和网关</li>
<li>数据同步和备份</li>
</ul>
<h3 id="9-5-以Raft-KV项目为例"><a href="#9-5-以Raft-KV项目为例" class="headerlink" title="9.5 以Raft KV项目为例"></a>9.5 以Raft KV项目为例</h3><h4 id="单容器Pod部署（推荐）"><a href="#单容器Pod部署（推荐）" class="headerlink" title="单容器Pod部署（推荐）"></a>单容器Pod部署（推荐）</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">raft-kv-node-0</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">raft-server</span>       <span class="comment"># 只有一个容器</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">raft-kv:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">10000</span></span><br><span class="line">    <span class="attr">env:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">NODE_ID</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&quot;0&quot;</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">raft-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">raft-data</span></span><br><span class="line">    <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">      <span class="attr">claimName:</span> <span class="string">raft-storage-0</span></span><br></pre></td></tr></table></figure>

<h4 id="多容器Pod部署（高级场景）"><a href="#多容器Pod部署（高级场景）" class="headerlink" title="多容器Pod部署（高级场景）"></a>多容器Pod部署（高级场景）</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">raft-kv-node-0-enhanced</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">raft-server</span>           <span class="comment"># 主应用容器</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">raft-kv:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">10000</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">raft-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-collector</span>         <span class="comment"># 日志收集容器</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">fluentd:v1.14</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">logs</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/var/log</span></span><br><span class="line">  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">metrics-exporter</span>      <span class="comment"># 监控指标容器</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">prometheus-exporter:v1.0</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">9090</span></span><br><span class="line">  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">backup-agent</span>          <span class="comment"># 备份代理容器</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">backup-agent:v1.0</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">raft-data</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-实践总结与最佳实践"><a href="#10-实践总结与最佳实践" class="headerlink" title="10. 实践总结与最佳实践"></a>10. 实践总结与最佳实践</h2><h3 id="10-1-核心概念总结"><a href="#10-1-核心概念总结" class="headerlink" title="10.1 核心概念总结"></a>10.1 核心概念总结</h3><h4 id="Kubernetes的本质"><a href="#Kubernetes的本质" class="headerlink" title="Kubernetes的本质"></a>Kubernetes的本质</h4><ul>
<li><strong>定位</strong>：分布式系统的基础设施抽象层</li>
<li><strong>作用</strong>：资源管理、调度、生命周期管理</li>
<li><strong>价值</strong>：自动化运维、标准化部署、服务治理</li>
</ul>
<h4 id="Pod的本质"><a href="#Pod的本质" class="headerlink" title="Pod的本质"></a>Pod的本质</h4><ul>
<li><strong>定义</strong>：Kubernetes的最小部署单元</li>
<li><strong>组成</strong>：一个或多个容器的集合</li>
<li><strong>特点</strong>：共享网络、存储、生命周期</li>
</ul>
<h4 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h4><ul>
<li><strong>过程</strong>：API Server → Scheduler → kubelet → 容器运行时</li>
<li><strong>结果</strong>：Pod运行在实际的物理机或虚拟机上</li>
<li><strong>控制</strong>：通过资源请求、节点选择器、亲和性等策略控制</li>
</ul>
<h3 id="10-2-设计原则和最佳实践"><a href="#10-2-设计原则和最佳实践" class="headerlink" title="10.2 设计原则和最佳实践"></a>10.2 设计原则和最佳实践</h3><h4 id="容器设计原则"><a href="#容器设计原则" class="headerlink" title="容器设计原则"></a>容器设计原则</h4><ol>
<li><strong>优先使用单容器Pod</strong>：简单、清晰、易管理</li>
<li><strong>多容器Pod的使用条件</strong>：<ul>
<li>容器间需要共享文件系统</li>
<li>容器间需要共享网络（localhost通信）</li>
<li>容器生命周期紧密耦合</li>
<li>容器需要同时调度到同一节点</li>
</ul>
</li>
</ol>
<h4 id="部署策略"><a href="#部署策略" class="headerlink" title="部署策略"></a>部署策略</h4><ol>
<li><p><strong>渐进式迁移</strong>：</p>
<ul>
<li>第一步：容器化应用</li>
<li>第二步：单Pod部署</li>
<li>第三步：添加K8s特性</li>
<li>第四步：完整的云原生架构</li>
</ul>
</li>
<li><p><strong>环境选择</strong>：</p>
<ul>
<li>开发环境：Minikube、Kind、Docker Desktop</li>
<li>测试环境：kubeadm集群</li>
<li>生产环境：云服务商托管或自建高可用集群</li>
</ul>
</li>
</ol>
<h3 id="10-3-常见问题和解决方案"><a href="#10-3-常见问题和解决方案" class="headerlink" title="10.3 常见问题和解决方案"></a>10.3 常见问题和解决方案</h3><h4 id="问题1：Pod调度失败"><a href="#问题1：Pod调度失败" class="headerlink" title="问题1：Pod调度失败"></a>问题1：Pod调度失败</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看调度失败原因</span></span><br><span class="line">kubectl describe pod my-pod</span><br><span class="line">kubectl get events --sort-by=.metadata.creationTimestamp</span><br></pre></td></tr></table></figure>

<p><strong>常见原因</strong>：</p>
<ul>
<li>资源不足</li>
<li>节点不可用</li>
<li>镜像拉取失败</li>
<li>存储卷挂载失败</li>
</ul>
<h4 id="问题2：容器启动失败"><a href="#问题2：容器启动失败" class="headerlink" title="问题2：容器启动失败"></a>问题2：容器启动失败</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器日志</span></span><br><span class="line">kubectl logs my-pod</span><br><span class="line">kubectl logs my-pod --previous</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器调试</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-pod -- /bin/bash</span><br></pre></td></tr></table></figure>

<h4 id="问题3：网络连通性问题"><a href="#问题3：网络连通性问题" class="headerlink" title="问题3：网络连通性问题"></a>问题3：网络连通性问题</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试Pod网络</span></span><br><span class="line">kubectl <span class="built_in">exec</span> my-pod -- ping other-pod-ip</span><br><span class="line">kubectl <span class="built_in">exec</span> my-pod -- nslookup my-service</span><br></pre></td></tr></table></figure>

<h3 id="10-4-监控和运维"><a href="#10-4-监控和运维" class="headerlink" title="10.4 监控和运维"></a>10.4 监控和运维</h3><h4 id="基础监控"><a href="#基础监控" class="headerlink" title="基础监控"></a>基础监控</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 资源使用监控</span></span><br><span class="line">kubectl top pods</span><br><span class="line">kubectl top nodes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 状态监控</span></span><br><span class="line">kubectl get pods -w</span><br><span class="line">kubectl get events -w</span><br></pre></td></tr></table></figure>

<h4 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志查看</span></span><br><span class="line">kubectl logs -f my-pod</span><br><span class="line">kubectl logs my-pod --since=1h --<span class="built_in">tail</span>=100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多容器Pod的日志</span></span><br><span class="line">kubectl logs my-pod -c container-name</span><br></pre></td></tr></table></figure>

<h3 id="10-5-学习路径建议"><a href="#10-5-学习路径建议" class="headerlink" title="10.5 学习路径建议"></a>10.5 学习路径建议</h3><h4 id="初学者路径"><a href="#初学者路径" class="headerlink" title="初学者路径"></a>初学者路径</h4><ol>
<li><strong>理解概念</strong>：Pod、Service、Deployment的基本概念</li>
<li><strong>本地实践</strong>：使用Minikube搭建本地环境</li>
<li><strong>简单部署</strong>：部署单容器应用</li>
<li><strong>逐步深入</strong>：学习网络、存储、配置管理</li>
</ol>
<h4 id="进阶路径"><a href="#进阶路径" class="headerlink" title="进阶路径"></a>进阶路径</h4><ol>
<li><strong>多容器Pod</strong>：理解Sidecar模式</li>
<li><strong>服务网格</strong>：Istio、Linkerd等</li>
<li><strong>运维工具</strong>：Helm、Kustomize等</li>
<li><strong>监控告警</strong>：Prometheus、Grafana等</li>
</ol>
<h4 id="专家路径"><a href="#专家路径" class="headerlink" title="专家路径"></a>专家路径</h4><ol>
<li><strong>自定义控制器</strong>：Operator开发</li>
<li><strong>集群管理</strong>：高可用、灾备、升级</li>
<li><strong>性能优化</strong>：资源调优、网络优化</li>
<li><strong>安全加固</strong>：RBAC、网络策略、Pod安全策略</li>
</ol>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong>Kubernetes不是侵入性框架</strong>，而是基础设施抽象层</li>
<li><strong>Pod不是容器</strong>，而是容器的包装器和管理单元</li>
<li><strong>调度不是黑箱</strong>，而是可理解和可控制的资源分配过程</li>
<li><strong>复杂性是可管理的</strong>，通过渐进式学习和实践可以掌握</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/k8s%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/" data-id="cmfe5ab600000hgpv95ne7f5h" data-title="k8s深入理解" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8%E7%BB%84/" rel="tag">容器组</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/" rel="tag">容器编排</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-验证二叉树搜索" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/10/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2/" class="article-date">
  <time class="dt-published" datetime="2025-09-10T13:50:58.000Z" itemprop="datePublished">2025-09-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/10/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2/">验证二叉搜索树</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>本题为 <strong>力扣 98. 验证二叉搜索树</strong>。<br>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效二叉搜索树定义如下：</strong></p>
<ol>
<li>节点的左子树只包含 <strong>严格小于</strong> 当前节点的数。  </li>
<li>节点的右子树只包含 <strong>严格大于</strong> 当前节点的数。  </li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ol>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>因为本题涉及二叉树的遍历，通常使用 <strong>递归</strong> 来完成。<br>需要注意的一点是：<br>判断 BST 时，比较的是 <strong>整个子树</strong> 是否满足条件，而不是仅比较 <strong>左右子节点</strong>。</p>
<p>因此每次递归到一个节点时，需要检查它是否在 <strong>祖先节点传下来的约束范围</strong> 内。<br>即：递归时为每个节点维护一个区间 <code>(min, max)</code>。  </p>
<p>递归规则如下：</p>
<ul>
<li><p>左子树递归时：<br><code>helper(node.Left, min, node.Val)</code>  </p>
</li>
<li><p>右子树递归时：<br><code>helper(node.Right, node.Val, max)</code></p>
</li>
</ul>
<p>为什么每次只更新一边？<br>因为约束是延续的：  </p>
<ul>
<li>对左子树来说，最大值受当前节点的值限制；  </li>
<li>对右子树来说，最小值受当前节点的值限制。</li>
</ul>
<hr>
<h2 id="代码实现（Go）"><a href="#代码实现（Go）" class="headerlink" title="代码实现（Go）"></a>代码实现（Go）</h2><pre><code class="language-go">/**
 * Definition for a binary tree node.
 * type TreeNode struct &#123;
 *     Val   int
 *     Left  *TreeNode
 *     Right *TreeNode
 * &#125;
 */
func isValidBST(root *TreeNode) bool &#123;
    return helper(root, nil, nil)
&#125;

func helper(node *TreeNode, min *int, max *int) bool &#123;
    if node == nil &#123;
        return true
    &#125;
    if min != nil &amp;&amp; node.Val &lt;= *min &#123;
        return false
    &#125;
    if max != nil &amp;&amp; node.Val &gt;= *max &#123;
        return false
    &#125;
    return helper(node.Left, min, &amp;node.Val) &amp;&amp; helper(node.Right, &amp;node.Val, max)
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/10/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2/" data-id="cmfe1vx4d00001opv00883w7s" data-title="验证二叉搜索树" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-go的注意事项" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/09/go%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" class="article-date">
  <time class="dt-published" datetime="2025-09-09T14:26:44.000Z" itemprop="datePublished">2025-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/09/go%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/">go的注意事项</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>总结一下 C++ 转 Go 需要注意的事项。</p>
<h2 id="1-Go-没有构造函数和析构函数"><a href="#1-Go-没有构造函数和析构函数" class="headerlink" title="1. Go 没有构造函数和析构函数"></a>1. Go 没有构造函数和析构函数</h2><p>Go 追求简单，并且自带内存管理（GC），不需要像 C++ 那样在构造和析构时进行大量内存声明和释放操作，因此没有构造函数和析构函数。Go 提供了三种对象创建方式：</p>
<h3 id="（1）直接使用结构体字面量（Literal）"><a href="#（1）直接使用结构体字面量（Literal）" class="headerlink" title="（1）直接使用结构体字面量（Literal）"></a>（1）直接使用结构体字面量（Literal）</h3><p>这是最简单、最直接的方式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 按字段顺序初始化</span></span><br><span class="line">    p1 := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按字段名初始化（推荐，顺序不重要）</span></span><br><span class="line">    p2 := Person&#123;</span><br><span class="line">        Name: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">        Age:  <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line">### （<span class="number">2</span>）使用指针和字面量（动态分配）</span><br><span class="line"></span><br><span class="line">如果希望对象在堆上分配，并通过指针进行引用：</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">p := &amp;Person&#123;</span></span><br><span class="line"><span class="string">    Name: &quot;Charlie&quot;,</span></span><br><span class="line"><span class="string">    Age:  40,</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）工厂函数"><a href="#（3）工厂函数" class="headerlink" title="（3）工厂函数"></a>（3）工厂函数</h3><p>在对象成员赋值的同时，可以进行逻辑化处理，比如默认值、验证或依赖注入：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="type">string</span>, age <span class="type">int</span>)</span></span> *Person &#123;</span><br><span class="line">    <span class="keyword">if</span> age &lt; <span class="number">0</span> &#123;</span><br><span class="line">        age = <span class="number">0</span> <span class="comment">// 保证合法年龄</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;Person&#123;</span><br><span class="line">        Name: name,</span><br><span class="line">        Age:  age,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := NewPerson(<span class="string">&quot;David&quot;</span>, <span class="number">-5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：C++ 在对象拷贝时会自动调用编译器生成的构造函数，而 Go 只是简单逐个拷贝变量。如果涉及指针，需要注意拷贝后是否为同一段地址，成员是否共享。</p>
</blockquote>
<hr>
<h2 id="2-Go-没有成员函数"><a href="#2-Go-没有成员函数" class="headerlink" title="2. Go 没有成员函数"></a>2. Go 没有成员函数</h2><p>Go 引入了 <strong>接收者（receiver）</strong> 的概念，将函数绑定到 struct 上：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法绑定在 Person 上</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> SetName(name <span class="type">string</span>) &#123;</span><br><span class="line">    p.Name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    person := &amp;Person&#123;&#125;</span><br><span class="line">    person.SetName(<span class="string">&quot;Alice&quot;</span>) <span class="comment">// 调用语法像成员函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器实际翻译为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetName(person, <span class="string">&quot;Alice&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本质上类似 C++ 的成员函数，C++ 是隐式传入 <code>this</code> 指针，而 Go 是显式传入接收者指针。</p>
</blockquote>
<hr>
<h2 id="3-Go-没有类继承，依靠接口实现多态"><a href="#3-Go-没有类继承，依靠接口实现多态" class="headerlink" title="3. Go 没有类继承，依靠接口实现多态"></a>3. Go 没有类继承，依靠接口实现多态</h2><p>Go 使用 <strong>组合和接口</strong> 来实现多态，不存在虚函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Speaker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Speak() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span></span> Speak() <span class="type">string</span> &#123;   <span class="comment">// 指针接收者可以修改状态</span></span><br><span class="line">    p.Name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hi, I&#x27;m &quot;</span> + p.Name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> s Speaker</span><br><span class="line">    p := &amp;Person&#123;Name: <span class="string">&quot;Alice&quot;</span>&#125;</span><br><span class="line">    s = p</span><br><span class="line">    fmt.Println(s.Speak())  <span class="comment">// Hi, I&#x27;m Bob</span></span><br><span class="line">    fmt.Println(p.Name)     <span class="comment">// Bob</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>接口变量 <code>s</code> 不存状态，只是方法集。</li>
<li><code>p</code> 持有状态。</li>
<li>方法通过接收者访问状态。</li>
<li>组合接口 + 接收者 → 多态 + 可变状态。</li>
</ul>
<blockquote>
<p>Go 的鸭子原则要求：类型要被视为接口，必须实现接口的所有方法。编译器会自动认定该类型实现了接口。接口不是对象，也不是类，只是一组方法签名的集合。带接收者的函数就是该类型的方法，所有方法合起来构成类型的方法集，且方法集是静态属性，编译器完全可知。在多态调用时，编译器会检查类型的方法集是否完全覆盖接口的方法集，否则报错。在内存层面，接口变量存储动态类型和具体值（或指针），方法调用时通过方法表查找具体类型的实现，从而实现多态。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/09/go%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/" data-id="cmfcpncno00004cpv9ea43a53" data-title="go的注意事项" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" rel="tag">语法基础</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-LRU算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/09/LRU%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2025-09-09T13:13:18.000Z" itemprop="datePublished">2025-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/09/LRU%E7%AE%97%E6%B3%95/">LRU算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本题为力扣 <strong>146. LRU 缓存</strong>：<br>请你设计并实现一个满足 <strong>LRU (最近最少使用) 缓存</strong> 约束的数据结构。</p>
<hr>
<h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code>：以正整数作为容量 capacity 初始化 LRU 缓存。</li>
<li><code>int get(int key)</code>：如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1。</li>
<li><code>void put(int key, int value)</code>：如果关键字 key 已经存在，则变更其数据值 value；如果不存在，则向缓存中插入该组 key-value 。<br>如果插入操作导致关键字数量超过 capacity ，则应该逐出最久未使用的关键字。</li>
</ul>
<p>要求：函数 <code>get</code> 和 <code>put</code> 必须以 <strong>O(1)</strong> 的平均时间复杂度运行。</p>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>分为三步：</p>
<ol>
<li><p><strong>构造函数</strong><br>初始化 <code>LRUCache</code> 类，维护好容量即可。</p>
</li>
<li><p><strong>核心思想</strong><br>整个算法就是实现两个主要操作：<code>get</code> 和 <code>put</code>。  </p>
<ul>
<li>只要有数据被访问（无论是读还是写），都属于“最近使用”，放到链表头。</li>
</ul>
</li>
<li><p><strong>具体操作</strong>  </p>
<ul>
<li><strong>GET</strong>：查找 key → value，如果没找到返回 -1；如果找到了，移动该节点到链表头。  </li>
<li><strong>PUT</strong>：  <ul>
<li>如果 key 存在，更新 value 并移动到链表头。  </li>
<li>如果 key 不存在，判断容量是否已满：  <ul>
<li>若已满，删除链表尾部节点（最久未使用）。  </li>
<li>插入新的 <code>(key,value)</code> 到链表头。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="代码实现-C"><a href="#代码实现-C" class="headerlink" title="代码实现 (C++)"></a>代码实现 (C++)</h2><pre><code class="language-cpp">#include &lt;list&gt;
#include &lt;unordered_map&gt;
using namespace std;

class LRUCache &#123;
public:
    LRUCache(int capacity) &#123;
        this-&gt;capacity = capacity;
    &#125;
    
    int get(int key) &#123;
        auto it = map.find(key);
        if (it == map.end()) &#123;
            return -1;
        &#125;
        // 移动到链表头
        cache.splice(cache.begin(), cache, it-&gt;second);
        return it-&gt;second-&gt;second;
    &#125;
    
    void put(int key, int value) &#123;
        auto it = map.find(key);
        if (it != map.end()) &#123;
            // 更新 value，并移动到链表头
            it-&gt;second-&gt;second = value;
            cache.splice(cache.begin(), cache, it-&gt;second);
        &#125; else &#123;
            // 容量已满，删除尾部
            if (cache.size() == capacity) &#123;
                auto del = cache.back();
                map.erase(del.first);
                cache.pop_back();
            &#125;
            // 插入新节点到头部
            cache.emplace_front(key, value);
            map[key] = cache.begin();
        &#125;
    &#125;

private:
    int capacity;
    list&lt;pair&lt;int,int&gt;&gt; cache; // 双向链表：头=最近使用，尾=最久未使用
    unordered_map&lt;int, list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; map; // 哈希表：key -&gt; 链表节点
&#125;;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/09/LRU%E7%AE%97%E6%B3%95/" data-id="cmfcmevr80003a9pvbt97gw9c" data-title="LRU算法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LRU/" rel="tag">LRU</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-探究docker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/31/%E6%8E%A2%E7%A9%B6docker/" class="article-date">
  <time class="dt-published" datetime="2025-08-31T14:47:08.000Z" itemprop="datePublished">2025-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/31/%E6%8E%A2%E7%A9%B6docker/">探究docker</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="容器技术的发展与启示"><a href="#容器技术的发展与启示" class="headerlink" title="容器技术的发展与启示"></a>容器技术的发展与启示</h1><p>总的来说，docker就是轻量化的虚拟机，选取了进程运行必须依赖的操作系统模块，进行项目部署。</p>
<h2 id="容器出现之前：部署的痛点"><a href="#容器出现之前：部署的痛点" class="headerlink" title="容器出现之前：部署的痛点"></a>容器出现之前：部署的痛点</h2><p>在容器（以 <strong>Docker</strong> 为代表的技术）出现之前，程序的部署往往有两类模式：</p>
<h3 id="1-直接部署"><a href="#1-直接部署" class="headerlink" title="1. 直接部署"></a>1. 直接部署</h3><ul>
<li><strong>方式</strong>：将程序直接部署到机器上运行，使用 <code>systemd</code> 等守护进程管理业务程序。  </li>
<li><strong>优点</strong>：方便查看程序运行情况，支持手动&#x2F;自动化启停。  </li>
<li><strong>缺点</strong>：  <ul>
<li>仅管理了业务程序本身，<strong>不管理依赖</strong>。  </li>
<li>新增机器时需手动安装依赖，依赖复杂且多版本共存困难。  </li>
<li>多个程序在同一台机器上可能发生依赖冲突（如 A 需要 X v1.0，而 B 需要 X v2.0，二者无法共存）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>总结：依赖安装简单，但依赖冲突和版本差异导致部署效率低、稳定性差，运维人员和开发者都很痛苦。</p>
</blockquote>
<h3 id="2-虚拟机隔离"><a href="#2-虚拟机隔离" class="headerlink" title="2. 虚拟机隔离"></a>2. 虚拟机隔离</h3><ul>
<li><strong>思路</strong>：将程序与依赖环境完全绑定，作为独立单元（虚拟机镜像）进行管理。  </li>
<li><strong>优点</strong>：  <ul>
<li>彻底解决依赖冲突问题。</li>
</ul>
</li>
<li><strong>缺点</strong>：  <ul>
<li><strong>镜像庞大</strong>：存储和传输成本高。  </li>
<li><strong>启停缓慢</strong>：需要完整的操作系统启动。  </li>
<li><strong>性能损耗大</strong>：多套内核进程导致资源浪费。</li>
</ul>
</li>
</ul>
<p>虚拟机解决了依赖冲突，但引入了新的性能与效率问题。</p>
<hr>
<h2 id="容器的基石：轻量化虚拟化技术"><a href="#容器的基石：轻量化虚拟化技术" class="headerlink" title="容器的基石：轻量化虚拟化技术"></a>容器的基石：轻量化虚拟化技术</h2><p>容器的目标是在解决依赖管理的同时，克服虚拟机的缺陷：<strong>镜像过大、启停缓慢、性能损耗</strong>。  </p>
<h3 id="1-解决镜像过大：UnionFS"><a href="#1-解决镜像过大：UnionFS" class="headerlink" title="1. 解决镜像过大：UnionFS"></a>1. 解决镜像过大：UnionFS</h3><ul>
<li><strong>虚拟机镜像庞大原因</strong>：每个镜像都包含操作系统的所有文件，存在大量冗余。  </li>
<li><strong>优化思路</strong>：相同文件只保存一份，不同镜像共享，通过 <strong>Copy-on-Write</strong> 机制解决修改冲突。  </li>
<li><strong>实现技术</strong>：联合文件系统（UnionFS，2004 年出现）。</li>
</ul>
<h3 id="2-解决启停缓慢：Namespace-Cgroups"><a href="#2-解决启停缓慢：Namespace-Cgroups" class="headerlink" title="2. 解决启停缓慢：Namespace + Cgroups"></a>2. 解决启停缓慢：Namespace + Cgroups</h3><ul>
<li><strong>问题</strong>：虚拟机启停包含完整操作系统开销。  </li>
<li><strong>解决</strong>：利用 Linux 的 <strong>Namespace</strong> 和 <strong>Cgroups</strong> 实现轻量级隔离：  <ul>
<li><strong>Namespace</strong>：隔离文件系统、进程视图、通信、网络、用户权限。  </li>
<li><strong>Cgroups</strong>：限制与分配 CPU、内存等硬件资源，避免资源抢占。</li>
</ul>
</li>
<li><strong>代表</strong>：LXC（Linux Containers，2008 年成型）。</li>
</ul>
<h3 id="3-解决性能损耗：共享内核"><a href="#3-解决性能损耗：共享内核" class="headerlink" title="3. 解决性能损耗：共享内核"></a>3. 解决性能损耗：共享内核</h3><ul>
<li><strong>虚拟机的损耗</strong>：多套操作系统导致重复进程与资源消耗。  </li>
<li><strong>容器的优化</strong>：所有容器共享宿主机内核，避免冗余内核进程。  </li>
<li><strong>结果</strong>：显著降低运行损耗，性能接近原生。</li>
</ul>
<hr>
<h2 id="Docker-的出现"><a href="#Docker-的出现" class="headerlink" title="Docker 的出现"></a>Docker 的出现</h2><p>虽然容器相关技术（UnionFS、LXC）已经出现，但 <strong>缺乏完整的体系化方案</strong>。  </p>
<h3 id="为什么是-Docker？"><a href="#为什么是-Docker？" class="headerlink" title="为什么是 Docker？"></a>为什么是 Docker？</h3><ul>
<li><strong>整合核心技术</strong>：基于 LXC 和 UnionFS，结合镜像机制。  </li>
<li><strong>标准化交付</strong>：提供完整的打包（Dockerfile）、版本管理（Image）、分发（Registry）、运行管理（Runtime）。  </li>
<li><strong>易用性极高</strong>：满足了开发者和运维的需求，实现 <strong>“Build once, Run anywhere”</strong>。  </li>
<li><strong>命名寓意</strong>：Docker &#x3D; 集装箱 → 软件交付标准化。  </li>
<li><strong>开源传播</strong>：免费、开源，迅速成为容器领域的事实标准。</li>
</ul>
<hr>
<h2 id="我们能学到什么？"><a href="#我们能学到什么？" class="headerlink" title="我们能学到什么？"></a>我们能学到什么？</h2><h3 id="1-面向需求而不是面向技术"><a href="#1-面向需求而不是面向技术" class="headerlink" title="1. 面向需求而不是面向技术"></a>1. 面向需求而不是面向技术</h3><ul>
<li>真正有价值的产品解决的是 <strong>普遍痛点</strong>，而不是单纯追求技术上的极致。</li>
</ul>
<h3 id="2-技术领域的组合创新"><a href="#2-技术领域的组合创新" class="headerlink" title="2. 技术领域的组合创新"></a>2. 技术领域的组合创新</h3><ul>
<li>Docker 的成功不是凭空创造，而是整合了已有的底层技术（UnionFS、LXC）。  </li>
<li>要求工程师熟悉底层能力，能在合适时机进行组合。</li>
</ul>
<h3 id="3-渐进式、问题驱动"><a href="#3-渐进式、问题驱动" class="headerlink" title="3. 渐进式、问题驱动"></a>3. 渐进式、问题驱动</h3><ul>
<li>技术演进是一个渐进的过程：  <ul>
<li>直接部署 → 虚拟机 → 容器。</li>
</ul>
</li>
<li>每一步都是为了解决新的问题，而不是一蹴而就。</li>
</ul>
<h3 id="4-避开定势思维"><a href="#4-避开定势思维" class="headerlink" title="4. 避开定势思维"></a>4. 避开定势思维</h3><ul>
<li>直接部署：执着于依赖管理 → 失败。  </li>
<li>虚拟机：执着于优化虚拟机 → 难以突破。  </li>
<li>容器：换思路 → 通过系统底层能力实现轻量化隔离。</li>
</ul>
<blockquote>
<p>启示：新的、更优秀的方案往往不是旧方案的改进，而是 <strong>根本性的思维变革</strong>。</p>
</blockquote>
<h2 id="docker如何使用"><a href="#docker如何使用" class="headerlink" title="docker如何使用"></a>docker如何使用</h2><h3 id="1-编写dockerfile"><a href="#1-编写dockerfile" class="headerlink" title="1. 编写dockerfile"></a>1. 编写dockerfile</h3><pre><code>在项目根目录创建一个dockerfile，在里面描述程序运行所需的环境（操作系统，依赖库，运行命令等）
</code></pre>
<h3 id="2-构建镜像"><a href="#2-构建镜像" class="headerlink" title="2. 构建镜像"></a>2. 构建镜像</h3><pre><code>docker会读取dockerfile，逐层执行，生成一个镜像，每条指令对应镜像的一层（layer），方便使用
</code></pre>
<h3 id="3-运行容器"><a href="#3-运行容器" class="headerlink" title="3.运行容器"></a>3.运行容器</h3><pre><code>容器 = 镜像＋可写层
</code></pre>
<h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><pre><code>查看容器：docker ps
停止容器：docker stop &lt;id&gt;
查看容器：docker logs &lt;id&gt;
进入容器：docker exe -it &lt;id&gt; /bin/bash
发布容器（将镜像推送到远程仓库）：docker push name
</code></pre>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/31/%E6%8E%A2%E7%A9%B6docker/" data-id="cmfcmevro000ga9pvcyxr6lof" data-title="探究docker" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-归并排序" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/08/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" class="article-date">
  <time class="dt-published" datetime="2025-08-25T14:58:29.000Z" itemprop="datePublished">2025-08-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/08/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">链表归并排序</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>归并排序也就是分治思想，时间复杂度为O（nlogn），且属于稳定排序</p>
<p>流程：</p>
<ol>
<li><p><strong>分</strong>：递归地把数组分成两半，直到每个子数组只有一个元素（天然有序），其实也就是分到符合条件为止，在这里也就是有序。</p>
</li>
<li><p><strong>治</strong>：把两个有序子数组 <strong>合并</strong> 成一个更大的有序数组，也就是将已经符合条件的部分进行合并。</p>
</li>
<li><p>分解：<br>[4, 2, 1, 3]<br>→ [4, 2] [1, 3]<br>→ [4] [2] [1] [3]</p>
</li>
<li><p>合并：<br>[4] + [2] → [2, 4]<br>[1] + [3] → [1, 3]<br>[2, 4] + [1, 3] → [1, 2, 3, 4]</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/08/25/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" data-id="cmfcmevrn000fa9pv48ac6oa9" data-title="链表归并排序" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" rel="tag">算法总结</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPU-CISC-RISC-%E6%8C%87%E4%BB%A4%E9%9B%86-%E6%9E%B6%E6%9E%84/" rel="tag">CPU, CISC, RISC, 指令集, 架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPU-%E6%8C%87%E4%BB%A4%E9%9B%86-%E6%B5%81%E6%B0%B4%E7%BA%BF-%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/" rel="tag">CPU, 指令集, 流水线, 分支预测</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPC%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" rel="tag">IPC，进程通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LRU/" rel="tag">LRU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ai/" rel="tag">ai</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/" rel="tag">事件驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E6%B1%A0-malloc-%E6%8C%87%E9%92%88/" rel="tag">内存管理, 内存池, malloc, 指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E7%A8%8B/" rel="tag">协程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85-%E4%BA%92%E6%96%A5%E9%94%81-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E4%BF%A1%E5%8F%B7%E9%87%8F/" rel="tag">多线程, 生产者消费者, 互斥锁, 条件变量, 信号量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/" rel="tag">多线程,同步,异步,阻塞,非阻塞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/" rel="tag">多进程, 进程状态</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" rel="tag">多进程, 进程通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8%E7%BB%84/" rel="tag">容器组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/" rel="tag">容器编排</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" rel="tag">工程实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%93%E6%96%87%E4%BB%B6/" rel="tag">库文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%95%E5%B1%82%E7%BC%96%E8%AF%91/" rel="tag">底层编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%90%E6%95%88/" rel="tag">提效</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E5%86%85%E6%A0%B8-IO/" rel="tag">文件描述符, 内核, IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E6%8A%A5/" rel="tag">日报</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88%E5%8C%BA-%E5%A0%86%E5%8C%BA-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E6%A0%87%E5%87%86%E5%BA%93-%E9%93%BE%E8%A1%A8/" rel="tag">栈区, 堆区, 系统调用, 标准库, 链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" rel="tag">算法总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%88%B7%E9%A2%98%EF%BC%8C%E5%9B%BE%E8%AE%BA%EF%BC%8CDFS/" rel="tag">算法，刷题，图论，DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5-%E4%BA%92%E6%96%A5%E9%94%81-%E8%AF%BB%E5%86%99%E9%94%81/" rel="tag">线程, 同步, 互斥锁, 读写锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B/" rel="tag">线程, 进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%88%E7%AB%AF-%E8%BF%9B%E7%A8%8B%E7%BB%84-%E4%BC%9A%E8%AF%9D-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" rel="tag">终端, 进程组, 会话, 守护进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8Clinux%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" rel="tag">虚拟机，linux，虚拟内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" rel="tag">语法基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CPU-CISC-RISC-%E6%8C%87%E4%BB%A4%E9%9B%86-%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">CPU, CISC, RISC, 指令集, 架构</a> <a href="/tags/CPU-%E6%8C%87%E4%BB%A4%E9%9B%86-%E6%B5%81%E6%B0%B4%E7%BA%BF-%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/" style="font-size: 10px;">CPU, 指令集, 流水线, 分支预测</a> <a href="/tags/DFS/" style="font-size: 10px;">DFS</a> <a href="/tags/IPC%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" style="font-size: 10px;">IPC，进程通信</a> <a href="/tags/LRU/" style="font-size: 10px;">LRU</a> <a href="/tags/ai/" style="font-size: 10px;">ai</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/golang/" style="font-size: 10px;">golang</a> <a href="/tags/k8s/" style="font-size: 10px;">k8s</a> <a href="/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/" style="font-size: 10px;">事件驱动</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">二叉树</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E6%B1%A0-malloc-%E6%8C%87%E9%92%88/" style="font-size: 10px;">内存管理, 内存池, malloc, 指针</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 20px;">刷题</a> <a href="/tags/%E5%8D%8F%E7%A8%8B/" style="font-size: 10px;">协程</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85-%E4%BA%92%E6%96%A5%E9%94%81-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E4%BF%A1%E5%8F%B7%E9%87%8F/" style="font-size: 10px;">多线程, 生产者消费者, 互斥锁, 条件变量, 信号量</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/" style="font-size: 10px;">多线程,同步,异步,阻塞,非阻塞</a> <a href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/" style="font-size: 10px;">多进程, 进程状态</a> <a href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" style="font-size: 10px;">多进程, 进程通信</a> <a href="/tags/%E5%AE%B9%E5%99%A8%E7%BB%84/" style="font-size: 10px;">容器组</a> <a href="/tags/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/" style="font-size: 10px;">容器编排</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" style="font-size: 10px;">工程实践</a> <a href="/tags/%E5%BA%93%E6%96%87%E4%BB%B6/" style="font-size: 10px;">库文件</a> <a href="/tags/%E5%BA%95%E5%B1%82%E7%BC%96%E8%AF%91/" style="font-size: 10px;">底层编译</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">归并排序</a> <a href="/tags/%E6%8F%90%E6%95%88/" style="font-size: 10px;">提效</a> <a href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E5%86%85%E6%A0%B8-IO/" style="font-size: 10px;">文件描述符, 内核, IO</a> <a href="/tags/%E6%97%A5%E6%8A%A5/" style="font-size: 10px;">日报</a> <a href="/tags/%E6%A0%88%E5%8C%BA-%E5%A0%86%E5%8C%BA-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E6%A0%87%E5%87%86%E5%BA%93-%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">栈区, 堆区, 系统调用, 标准库, 链表</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" style="font-size: 10px;">算法总结</a> <a href="/tags/%E7%AE%97%E6%B3%95%EF%BC%8C%E5%88%B7%E9%A2%98%EF%BC%8C%E5%9B%BE%E8%AE%BA%EF%BC%8CDFS/" style="font-size: 10px;">算法，刷题，图论，DFS</a> <a href="/tags/%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5-%E4%BA%92%E6%96%A5%E9%94%81-%E8%AF%BB%E5%86%99%E9%94%81/" style="font-size: 10px;">线程, 同步, 互斥锁, 读写锁</a> <a href="/tags/%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B/" style="font-size: 10px;">线程, 进程</a> <a href="/tags/%E7%BB%88%E7%AB%AF-%E8%BF%9B%E7%A8%8B%E7%BB%84-%E4%BC%9A%E8%AF%9D-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" style="font-size: 10px;">终端, 进程组, 会话, 守护进程</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">编程</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8Clinux%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" style="font-size: 10px;">虚拟机，linux，虚拟内存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">语法基础</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 15px;">递归</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">九月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">八月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">二月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">一月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/09/15/%E6%B7%B1%E6%8C%96%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/">深挖进程通信</a>
          </li>
        
          <li>
            <a href="/2025/09/14/AI%E7%BC%96%E7%A8%8B%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8A%80%E5%B7%A7/">AI编程提示词技巧</a>
          </li>
        
          <li>
            <a href="/2025/09/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/">岛屿数量</a>
          </li>
        
          <li>
            <a href="/2025/09/11/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/">路径总和</a>
          </li>
        
          <li>
            <a href="/2025/09/10/k8s%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/">k8s深入理解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Fxp<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>