<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Fxp&#39;Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Fxp&#39;Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Fxp&#39;Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Fxp">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Fxp'Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Fxp&#39;Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-括号生成" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/25/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/" class="article-date">
  <time class="dt-published" datetime="2025-09-25T15:13:52.000Z" itemprop="datePublished">2025-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/25/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/">括号生成</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本题为力扣 <strong>22. 括号生成</strong>：<br>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p>
<hr>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>1.这种回溯，实际就是在进行DFS</p>
<p>2.而且每一层只有两个选择，就没必要内部起一个循环了，直接两个分支就好</p>
<p>3.因为只存在一种括号，所以可以用left和right分别计数，每次递归只要判断left和right即可。</p>
<hr>
<h2 id="代码实现（C-）-左闭右开写法"><a href="#代码实现（C-）-左闭右开写法" class="headerlink" title="代码实现（C++）-左闭右开写法"></a>代码实现（C++）-左闭右开写法</h2><pre><code class="language-cpp">class Solution &#123;
public:
    vector&lt;string&gt; generateParenthesis(int n) &#123;
        vector&lt;string&gt; res;
        backtrack(res,&quot;&quot;,0,0,n);
        return res;
    &#125;

    void backtrack(vector&lt;string&gt;&amp;res,string path,int left,int right,int n)&#123;
        if(left == n&amp;&amp;right==n)&#123;
            res.push_back(path);
            return;
        &#125;

        if(left&lt;n)&#123;
            backtrack(res,path+&quot;(&quot;,left+1,right,n);
        &#125;
        if(right&lt;left)&#123;
            backtrack(res,path+&quot;)&quot;,left,right+1,n);
        &#125;
    &#125;
&#125;;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/25/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/" data-id="cmfzklt430000w3pv4zyr5chg" data-title="括号生成" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%AA%E6%9E%9D/" rel="tag">剪枝</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-组合总和" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/24/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/" class="article-date">
  <time class="dt-published" datetime="2025-09-24T15:34:22.000Z" itemprop="datePublished">2025-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/24/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/">组合总和</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本题为力扣 <strong>39. 组合总和</strong>：</p>
<p>给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150 个。</p>
<hr>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>1.首先注意到这题需要返回所有可行的路径，所以对于小规模数据可以用常规的递归方法，也就是向下传递临时数组，剪枝或者达标后，记录结果，然后返回，相当于销毁当前记录，回到上层，这就是递归的隐式回溯。</p>
<p>2.对于大量数据，一直创建销毁数组开销比较大，可以考虑维护一个全局的路径数组，每次进行手动入队和出队，完成显式的回溯。</p>
<p>3.而且对于这种路径探索的题目，实际就是用DFS，如何实现的呢，到了一个情况后，内部一定有for循环，循环内部一定有递归，这样保证探索到底，出来后还能在循环内继续向其他分支探索到底。</p>
<hr>
<h2 id="代码实现（C-）"><a href="#代码实现（C-）" class="headerlink" title="代码实现（C++）"></a>代码实现（C++）</h2><pre><code class="language-cpp">class Solution &#123;
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;

    void dfs(vector&lt;int&gt;&amp; candidates, int target, int start) &#123;
        if (target == 0) &#123; 
            res.push_back(path);
            return;
        &#125;
        for (int i = start; i &lt; candidates.size(); i++) &#123;
            if (candidates[i] &gt; target) break; 
            path.push_back(candidates[i]);
            dfs(candidates, target - candidates[i], i); 
            path.pop_back();
        &#125;
    &#125;

    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123;
        sort(candidates.begin(), candidates.end()); 
        dfs(candidates, target, 0);
        return res;
    &#125;
&#125;;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/24/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/" data-id="cmfy64knf0000gvpvgujt7l5u" data-title="组合总和" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%89%AA%E6%9E%9D/" rel="tag">回溯，剪枝</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-搜索旋转排序数组" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/23/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/" class="article-date">
  <time class="dt-published" datetime="2025-09-23T15:57:06.000Z" itemprop="datePublished">2025-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/23/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">搜索旋转排序数组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本题为力扣 <strong>33. 搜索旋转排序数组</strong>：<br>整数数组 nums 按升序排列，数组中的值 互不相同 。</p>
<p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;&#x3D; k &lt; nums.length）上进行了 向左旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 下标 3 上向左旋转后可能变为 [4,5,6,7,0,1,2] 。</p>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
<p>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>1.先来梳理一下二分查找的区间开闭问题：</p>
<table>
<thead>
<tr>
<th>写法</th>
<th>区间含义</th>
<th>初始 right</th>
<th>循环条件</th>
<th>mid 更新</th>
<th>注意点</th>
</tr>
</thead>
<tbody><tr>
<td>左闭右开 <code>[left, right)</code></td>
<td>包含 left，不包含 right</td>
<td><code>nums.size()</code></td>
<td><code>while(left &lt; right)</code></td>
<td><code>left = mid+1</code> 或 <code>right = mid</code></td>
<td>right 本身不可访问，只是边界</td>
</tr>
<tr>
<td>全闭 <code>[left, right]</code></td>
<td>包含 left 和 right</td>
<td><code>nums.size()-1</code></td>
<td><code>while(left &lt;= right)</code></td>
<td><code>left = mid+1</code> 或 <code>right = mid-1</code></td>
<td>right 可访问，mid ±1 不会漏元素</td>
</tr>
</tbody></table>
<p>2.然后本题比较特殊的就是，需要判断target可能在哪半边，通过直接对比mid值和左右边界来进行判断，如果nums[mid]大于左边界，说明target可能在左边，再进行细节判断，将target和mid与left进行对比，如果大于mid或者大于left，说明不在左半边，收缩左边界，否则说明在左半边，收缩右边界，以此类推</p>
<hr>
<h2 id="代码实现（C-）-左闭右开写法"><a href="#代码实现（C-）-左闭右开写法" class="headerlink" title="代码实现（C++）-左闭右开写法"></a>代码实现（C++）-左闭右开写法</h2><pre><code class="language-cpp">class Solution &#123;
public:
    int search(vector&lt;int&gt;&amp; nums, int target) &#123;
        int left = 0;
        int right = nums.size(); // [0, n)

        while(left &lt; right) &#123;
            int mid = (left + right) / 2;

            if(nums[mid] == target) &#123;
                return mid;
            &#125;

            if(nums[mid] &gt;= nums[left]) &#123;
                if(nums[left] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;
                    right = mid; 
                &#125; else &#123;
                    left = mid + 1;
                &#125;
            &#125; else &#123;
                if(nums[mid] &lt; target &amp;&amp; target &lt; nums[right-1]) &#123; 
                    left = mid + 1;
                &#125; else if (nums[mid] &lt; target &amp;&amp; target == nums[right-1]) &#123;
                    return right-1;
                &#125; else &#123;
                    right = mid;
                &#125;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/23/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/" data-id="cmfwr5pkk0000nypv89zd74uu" data-title="搜索旋转排序数组" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-二叉树的最近公共祖先" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" class="article-date">
  <time class="dt-published" datetime="2025-09-22T14:48:04.000Z" itemprop="datePublished">2025-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">二叉树的最近公共祖先</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本题为力扣 <strong>236. 二叉树的最近公共祖先</strong>：<br>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li><p>之前提到过，递归有传递变量和传递指针，这题就算传递指针的，下层改变指针值后会返回给上层。</p>
</li>
<li><p>递归入手一定要从函数本身入手，而不要过多考虑递归的变化过程，当前函数，对于传入的root，要如何处理？1.如果当前的节点为空，那当然直接返回空了，那也就是节点本身 2.如果当前节点是p或者q，说明找到了一个，返回当前节点 3.如果当前节点非空也非p或者q，那就分别递归左右子树，会获得两个递归结果，left和right，分别代表左跟右有没有pq，left !&#x3D; nullptr &amp;&amp; right !&#x3D; nullptr → 说明 p 在一边，q 在另一边，那么当前 root 就是最近公共祖先。 如果只有一边非空（比如 left 非空，right 为空），那就把非空的那个返回给上层。因为另一个目标节点肯定在其子树中。</p>
</li>
</ol>
<hr>
<h2 id="代码实现（C-）"><a href="#代码实现（C-）" class="headerlink" title="代码实现（C++）"></a>代码实现（C++）</h2><pre><code class="language-cpp">/**
 * Definition for a binary tree node.
 * struct TreeNode &#123;
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;
 * &#125;;
 */
class Solution &#123;
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123;
        if(root == nullptr||root ==p ||root==q)&#123;
            return root;
        &#125;

        TreeNode* left = lowestCommonAncestor(root-&gt;left,p,q);
        TreeNode* right = lowestCommonAncestor(root-&gt;right,p,q);

        if(left!= nullptr &amp;&amp; right!=nullptr)&#123;
            return root;
        &#125;
        return left!=nullptr?left:right;

    &#125;
&#125;;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" data-id="cmfvaxnqa0000ywpvcttn490n" data-title="二叉树的最近公共祖先" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数组中第k个最大元素" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/18/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/" class="article-date">
  <time class="dt-published" datetime="2025-09-18T14:09:16.000Z" itemprop="datePublished">2025-09-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/18/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/">数组中第k个最大元素</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本题为力扣 <strong>215. 数组中第k个最大元素</strong>：<br>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li><p>这题难度就在于不能用排序，就算是快排也要O（nlogn）,所以考虑借助堆来完成，也就是在插入时就排好序，用C++的优先队列来完成</p>
</li>
<li><p>由于优先队列无法随机访问，所以在插入时需要保持小顶堆大小为k，小于k时就加入，等于k就踢掉，最后拿堆顶</p>
</li>
</ol>
<hr>
<h2 id="代码实现（Go）"><a href="#代码实现（Go）" class="headerlink" title="代码实现（Go）"></a>代码实现（Go）</h2><pre><code class="language-go">class Solution &#123;
public:
    int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123;
        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq;
        for(int num:nums)&#123;
            if(pq.size()&lt;k)&#123;
                pq.push(num);
            &#125;else if(num&gt;pq.top())&#123;
                pq.pop();
                pq.push(num);
            &#125;
        &#125;
        return pq.top();
    &#125;
&#125;;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/18/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/" data-id="cmfpi7nta000r4rpvdk9782eh" data-title="数组中第k个最大元素" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" rel="tag">堆排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-电话号码的字母组合" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/17/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/" class="article-date">
  <time class="dt-published" datetime="2025-09-17T14:43:22.000Z" itemprop="datePublished">2025-09-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/17/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/">电话号码的字母组合</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本题为力扣 <strong>17. 电话号码的字母组合</strong>：<br>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<br>2-&gt;abc 3-&gt;def 4-&gt;ghi 5-&gt;jkl 6-&gt;mno 7-&gt;pqrs 8-&gt;tuv 9-&gt;wxyz</p>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li><p>回溯其实分为递归回溯和标记回溯，递归回溯就是就借助递归函数传递局部变量，这样在递归返回的时候，不会影响上层的变量，但是可以传给下层，进而完成回溯的过程。</p>
</li>
<li><p>就这题来说，典型的可以用递归回溯，因为整个过程就是一个递归树，所以可以一直传递一个局部变量来完成。但是像路径回溯的题目，因为一个格子不知道什么时候会被占用，所以必须要采取共享变量，也就是标记回溯。</p>
</li>
<li><p>本题首先提前声明好数字和字母的映射，然后写一个递归的回溯函数，首先判断当前状态是否满足，加入结果中，返回。如果不满足，对当前数字的所有字母进行遍历回溯。</p>
</li>
</ol>
<hr>
<h2 id="代码实现（Go）"><a href="#代码实现（Go）" class="headerlink" title="代码实现（Go）"></a>代码实现（Go）</h2><pre><code class="language-go">func letterCombinations(digits string) []string &#123;
    if len(digits) == 0&#123;
        return []string&#123;&#125;
    &#125;
    phone := map[byte]string&#123;
        &#39;2&#39;: &quot;abc&quot;,
        &#39;3&#39;: &quot;def&quot;,
        &#39;4&#39;: &quot;ghi&quot;,
        &#39;5&#39;: &quot;jkl&quot;,
        &#39;6&#39;: &quot;mno&quot;,
        &#39;7&#39;: &quot;pqrs&quot;,
        &#39;8&#39;: &quot;tuv&quot;,
        &#39;9&#39;: &quot;wxyz&quot;,
    &#125;

    var res []string

    var backtrace func(index int,path string)
    backtrace = func(index int,path string)&#123;
        if index == len(digits)&#123;
            res = append(res,path)
            return
        &#125;

        letters := phone[digits[index]]
        for i :=0;i&lt;len(letters);i++&#123;
            backtrace(index+1,path+string(letters[i]))
        &#125;
    &#125;
    backtrace(0,&quot;&quot;)
    return res
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/17/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/" data-id="cmfpi7nte000z4rpvc6c16hm4" data-title="电话号码的字母组合" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E5%90%88/" rel="tag">组合</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-深挖进程通信" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/15/%E6%B7%B1%E6%8C%96%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" class="article-date">
  <time class="dt-published" datetime="2025-09-15T15:07:06.000Z" itemprop="datePublished">2025-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/15/%E6%B7%B1%E6%8C%96%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/">深挖进程通信</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h1><h2 id="为什么进程之间可以通信？"><a href="#为什么进程之间可以通信？" class="headerlink" title="为什么进程之间可以通信？"></a>为什么进程之间可以通信？</h2><p>尽管用户进程空间有多个，但是内核空间只有一个，所有用户空间可以通过系统调用与内核空间交互，所以用户进程之间可以通过内核空间作为桥梁进行交互。</p>
<p>Linux 设置了两级保护机制：  </p>
<ul>
<li>0 级可由内核调用  </li>
<li>3 级可由用户调用</li>
</ul>
<p>进程空间通常为 3GB，最高的 1G 虚拟内存空间为所有进程和内核所共享。总的来说，内核就像中央控制室，一个进程可以将信息发给内核，另一个进程再从内核获得，以实现进程间通信。</p>
<h2 id="通信机制分类"><a href="#通信机制分类" class="headerlink" title="通信机制分类"></a>通信机制分类</h2><p>从机制上划分，进程间通信分为 <strong>共享内存式</strong> 和 <strong>消息传递式</strong>：</p>
<ul>
<li><p><strong>共享内存式</strong><br>通信中枢建立好通信信道后，通信双方之后的通信不需要通信中枢的协助。也正因如此，通信双方需要保证进程间同步，以保证数据读写的一致性，属于对称式的通信，双方平等在共享内存上进行通信。  </p>
</li>
<li><p><strong>消息传递式</strong><br>通信中枢建立好通信信道后，每次通信还都需要通信中枢的协助。  </p>
<ul>
<li><strong>无边界消息</strong>：是字节流，发过来是一个一个的字节，要靠进程自己设计如何区分消息的边界。  </li>
<li><strong>有边界消息</strong>：发送和接收都是以消息为基本单位，类似于一封封完整的信件，接收方可以明确地知道每个消息的开始和结束位置，属于非对称式通信，比如客户端向服务端发起请求，服务端处理好后发回客户端。</li>
</ul>
</li>
</ul>
<h2 id="通信接口需求"><a href="#通信接口需求" class="headerlink" title="通信接口需求"></a>通信接口需求</h2><p>实现进程间通信需要实现三类接口：  </p>
<ol>
<li><strong>如何建立通信信道</strong>：对于非对称的通信，一般由服务端或者消费者建立信道，客户端或者生产者加入信道。  </li>
<li><strong>如何找到并加入通信信道</strong>：一般是双方通过约定好的信道名字找到信道句柄，通过句柄加入通信信道。  </li>
<li><strong>如何使用通信信道</strong>：一般跟对文件句柄的操作差不多。</li>
</ol>
<hr>
<h2 id="常见的-IPC-方式"><a href="#常见的-IPC-方式" class="headerlink" title="常见的 IPC 方式"></a>常见的 IPC 方式</h2><h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h3><p>管道又分为 <strong>匿名管道</strong> 和 <strong>有名管道</strong>。</p>
<ul>
<li><p><strong>匿名管道</strong>  </p>
<ul>
<li>没有名字，是一种临时存放在内存中的单向数据通道，主要用于有关系的父子进程之间。  </li>
<li>工作原理基于文件描述符：一个进程调用 <code>pipe</code> 函数创建匿名管道时，会得到两个文件描述符，<code>fd[0]</code> 用于读，<code>fd[1]</code> 用于写。  </li>
<li>父子进程通过继承的文件描述符实现通信。  </li>
<li><strong>优点</strong>：实现简单，效率高，基于内存，速度快。  </li>
<li><strong>缺点</strong>：半双工，只能单向通信；仅限亲缘关系进程；缓冲区有限。</li>
</ul>
</li>
<li><p><strong>有名管道（FIFO）</strong>  </p>
<ul>
<li>在文件系统中有一个名字，可以用在没有亲缘关系的进程之间。  </li>
<li>使用 <code>mkfifo(&quot;myfifo&quot;, 0666)</code> 创建。  </li>
<li><strong>优点</strong>：可在任意进程间通信，生命周期独立于进程。  </li>
<li><strong>缺点</strong>：仍是半双工；需要文件系统操作，开销更大。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-信号"><a href="#2-信号" class="headerlink" title="2. 信号"></a>2. 信号</h3><ul>
<li>一种 <strong>异步事件通知机制</strong>。  </li>
<li>示例：按下 <code>Ctrl + C</code> → 内核向前台进程发送 <code>SIGINT</code> → 默认终止运行。  </li>
<li>进程处理信号的三种方式：  <ol>
<li>执行默认动作  </li>
<li>忽略信号  </li>
<li>自定义信号处理函数</li>
</ol>
</li>
<li><strong>优点</strong>：简单高效，能快速通知事件发生。  </li>
<li><strong>缺点</strong>：信息量有限，仅有信号编号；执行时机不确定，可能造成竞态问题。</li>
</ul>
<hr>
<h3 id="3-文件"><a href="#3-文件" class="headerlink" title="3. 文件"></a>3. 文件</h3><ul>
<li>原理：不同进程通过 <strong>读写同一文件</strong> 实现数据共享。  </li>
<li>场景：日志系统、配置文件共享。  </li>
<li>问题：并发写入会导致数据覆盖和一致性问题。  </li>
<li>解决办法：使用 <strong>文件锁</strong>（共享锁 &#x2F; 排他锁）。</li>
</ul>
<hr>
<h3 id="4-共享内存"><a href="#4-共享内存" class="headerlink" title="4. 共享内存"></a>4. 共享内存</h3><ul>
<li>允许多个进程访问同一内存区域，是一种高效的 IPC 机制。  </li>
<li>常用函数：<code>shmget</code>、<code>shmat</code>、<code>shmdt</code>、<code>shmctl</code>。</li>
</ul>
<hr>
<h3 id="5-消息队列"><a href="#5-消息队列" class="headerlink" title="5. 消息队列"></a>5. 消息队列</h3><ul>
<li>类似一个存放消息的“信箱”。  </li>
<li>本质：链表结构，每个节点存储一条消息（类型 + 内容）。  </li>
<li>特点：  <ul>
<li><strong>异步通信</strong>，发送方不必等待接收方。  </li>
<li><strong>解耦</strong>：进程只需关心消息队列，不直接依赖对方。</li>
</ul>
</li>
<li>应用：分布式系统中的任务请求和结果响应。</li>
</ul>
<hr>
<h3 id="6-Socket-通信"><a href="#6-Socket-通信" class="headerlink" title="6. Socket 通信"></a>6. Socket 通信</h3><ul>
<li>一种 <strong>网络通信形式</strong>。  </li>
<li>可用于 <strong>本地进程通信</strong>，也可用于 <strong>远程进程通信</strong>。</li>
</ul>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/15/%E6%B7%B1%E6%8C%96%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" data-id="cmfpi7ntc000u4rpvbf0y3tez" data-title="深挖进程通信" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IPC%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" rel="tag">IPC，进程通信</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-AI编程提示词技巧" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/14/AI%E7%BC%96%E7%A8%8B%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8A%80%E5%B7%A7/" class="article-date">
  <time class="dt-published" datetime="2025-09-14T15:32:46.000Z" itemprop="datePublished">2025-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/14/AI%E7%BC%96%E7%A8%8B%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8A%80%E5%B7%A7/">AI编程提示词技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="1-需求模糊，思维模糊，想法模糊时"><a href="#1-需求模糊，思维模糊，想法模糊时" class="headerlink" title="1. 需求模糊，思维模糊，想法模糊时"></a>1. 需求模糊，思维模糊，想法模糊时</h2><p>当需求不清晰时，直接向 AI 坦白，提供核心功能诉求，明确需要什么类型的帮助或方案设计。  </p>
<p><strong>示例提示词：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">我有一个模糊的想法：想做一个「&#123;产品/功能简述&#125;」。目前只确定核心目标是「&#123;核心目标&#125;」。请：</span><br><span class="line">1) 列出 4–6 种可行的实现方向；</span><br><span class="line">2) 每种方向写出关键技术与适用场景；</span><br><span class="line">3) 给出下一步必须澄清的 8 个问题。</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">```text</span><br><span class="line">场景：我要做一个能在手机上离线识别中文的模型，但不确定用轻量模型还是服务器推理。请帮我做决策矩阵：</span><br><span class="line">- 比较项：准确率、延迟、开发成本、部署复杂度、可维护性</span><br><span class="line">- 给出推荐方案，并写出 3 个实验思路。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-锁定范围，聚焦优化"><a href="#2-锁定范围，聚焦优化" class="headerlink" title="2. 锁定范围，聚焦优化"></a>2. 锁定范围，聚焦优化</h2><p>在优化代码时，提供当前状态作为基准点，列出明确的优化方向和具体需求，设定约束条件，让 AI 明白是在<strong>现有基础上优化</strong>。</p>
<p><strong>示例提示词：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是当前基线：</span><br><span class="line">- QPS=&#123;qps&#125;，p95=&#123;p95&#125;ms，内存=&#123;mem&#125;MB</span><br><span class="line">目标：把 p95 降低到 ≤ &#123;目标&#125;ms，要求不改架构。请给出 3 个优化方案（含改动点、预期效果、风险与回滚步骤）。</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我只允许在以下约束内优化：不能引入外部依赖；只能修改 &#123;模块名&#125;。请做代码审查式优化建议，输出格式：</span><br><span class="line">- 问题点</span><br><span class="line">- 建议修改</span><br><span class="line">- 预期效果</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-让-AI-扮演专家角色"><a href="#3-让-AI-扮演专家角色" class="headerlink" title="3. 让 AI 扮演专家角色"></a>3. 让 AI 扮演专家角色</h2><p>明确让 AI 扮演某类专家，从专业角度主动提出优化方案。</p>
<p><strong>示例提示词：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你现在是一个有 10 年经验的 Go 性能优化专家，请审查下面代码，并给出：</span><br><span class="line">1) 关键性能瓶颈（含依据）</span><br><span class="line">2) 改进代码示例</span><br><span class="line">3) 验证方法与预期提升幅度</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">你是分布式数据库架构师。系统写入量每小时 &#123;写入量&#125;，请基于 CAP、可用性、延迟权衡，给出两种架构方案并比较。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-正向激励，设定高期望与高优先级"><a href="#4-正向激励，设定高期望与高优先级" class="headerlink" title="4. 正向激励，设定高期望与高优先级"></a>4. 正向激励，设定高期望与高优先级</h2><p>通过设定目标与优先级，调用 AI 的积极性。</p>
<p><strong>示例提示词：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">优先级：性能 &gt; 正确性 &gt; 可读性。</span><br><span class="line">目标：p99 延迟从 &#123;old&#125;ms 降到 &#123;target&#125;ms。</span><br><span class="line">请输出：必须做（高）、建议做（中）、可选（低）的改进清单，并为必须做项写出实施计划。</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这是一个紧急修复：用户可见的崩溃。请先给出临时修复措施（最少代码改动），再给出长期根因修复建议。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-在必要时及时补充上下文"><a href="#5-在必要时及时补充上下文" class="headerlink" title="5. 在必要时及时补充上下文"></a>5. 在必要时及时补充上下文</h2><p>补充环境、日志、错误堆栈等上下文，避免信息差。</p>
<p><strong>示例提示词：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">我将提供上下文：</span><br><span class="line">- 环境：OS=&#123;os&#125;，语言/版本=&#123;ver&#125;，依赖版本=&#123;deps&#125;</span><br><span class="line">- 复现步骤：&#123;步骤&#125;</span><br><span class="line">- 日志/错误堆栈：&#123;日志&#125;</span><br><span class="line">- 期望行为 vs 实际行为</span><br><span class="line"></span><br><span class="line">请先列出你还需要的额外信息（最多 6 条），再基于现有上下文做 3 个可能原因分析和修复方案。</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给出数据库问题时，我会提供表结构、索引、执行计划、慢查询样本。请写出索引建议、SQL 重写示例，以及预计 IO 改善说明。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-分阶段设计"><a href="#6-分阶段设计" class="headerlink" title="6. 分阶段设计"></a>6. 分阶段设计</h2><p>采用「需求澄清 → 思路设计 → 方案输出 → 优化改进」的流程，避免信息一次过载。</p>
<p><strong>示例提示词：</strong></p>
<p><strong>Phase 1 — 需求澄清</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请以产品经理的角度，提出 10 个问题帮助澄清需求。每个问题后加一句说明：为什么问这个问题。</span><br></pre></td></tr></table></figure>

<p><strong>Phase 2 — 思路设计</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基于回答，给出 3 个可行方案（含优缺点、适用场景、关键风险）。</span><br></pre></td></tr></table></figure>

<p><strong>Phase 3 — 方案输出</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选定方案 A，输出：</span><br><span class="line">- 实现步骤（分里程碑）</span><br><span class="line">- 核心伪代码</span><br><span class="line">- 单元测试用例示例</span><br><span class="line">- 部署与回滚流程</span><br></pre></td></tr></table></figure>

<p><strong>Phase 4 — 优化改进</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现后，请给出 6 条优化建议（性能、可观测性、容错、可维护性、安全），并附量化指标和验证方法。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/14/AI%E7%BC%96%E7%A8%8B%E6%8F%90%E7%A4%BA%E8%AF%8D%E6%8A%80%E5%B7%A7/" data-id="cmfpi7nsk00004rpvaf4w8b6u" data-title="AI编程提示词技巧" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ai/" rel="tag">ai</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8F%90%E6%95%88/" rel="tag">提效</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-岛屿数量" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/" class="article-date">
  <time class="dt-published" datetime="2025-09-14T13:28:08.000Z" itemprop="datePublished">2025-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/">岛屿数量</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本题为力扣 <strong>200. 岛屿数量</strong>：<br>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
<p>示例 1：<br>输入：grid &#x3D; [<br>  [‘1’,’1’,’1’,’1’,’0’],<br>  [‘1’,’1’,’0’,’1’,’0’],<br>  [‘1’,’1’,’0’,’0’,’0’],<br>  [‘0’,’0’,’0’,’0’,’0’]<br>]<br>输出：1</p>
<p>示例 2：<br>输入：grid &#x3D; [<br>  [‘1’,’1’,’0’,’0’,’0’],<br>  [‘1’,’1’,’0’,’0’,’0’],<br>  [‘0’,’0’,’1’,’0’,’0’],<br>  [‘0’,’0’,’0’,’1’,’1’]<br>]<br>输出：3</p>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li><p>图论问题通常就是对者一个矩阵大做文章，比如检查连通性，找路径等等。而且经常涉及遍历图，通常用DFS和BFS。</p>
</li>
<li><p>岛屿就是联通的1，所以可以对点进行平均两次遍历，第一次遍历，如果当前格子为0或者越界，则返回，如果为1，则置零，并且向四个方向进行递归dfs。确保每一个联通的岛屿只计数1次</p>
</li>
</ol>
<hr>
<h2 id="代码实现（Go）"><a href="#代码实现（Go）" class="headerlink" title="代码实现（Go）"></a>代码实现（Go）</h2><pre><code class="language-go">func numIslands(grid [][]byte) int &#123;
    if len(grid) == 0 &#123;
        return 0
    &#125;

    rows, cols := len(grid), len(grid[0])
    var dfs func(r, c int)

    dfs = func(r, c int) &#123;
        // 边界条件
        if r &lt; 0 || c &lt; 0 || r &gt;= rows || c &gt;= cols || grid[r][c] == &#39;0&#39; &#123;
            return
        &#125;
        // 标记为水，表示访问过
        grid[r][c] = &#39;0&#39;

        // 上下左右四个方向
        dfs(r+1, c)
        dfs(r-1, c)
        dfs(r, c+1)
        dfs(r, c-1)
    &#125;

    count := 0
    for i := 0; i &lt; rows; i++ &#123;
        for j := 0; j &lt; cols; j++ &#123;
            if grid[i][j] == &#39;1&#39; &#123;
                count++
                dfs(i, j) // 把这个岛屿淹掉
            &#125;
        &#125;
    &#125;
    return count
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/14/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/" data-id="cmfpi7nt5000j4rpv9nu3gegq" data-title="岛屿数量" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-路径总和" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/09/11/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/" class="article-date">
  <time class="dt-published" datetime="2025-09-11T14:14:45.000Z" itemprop="datePublished">2025-09-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/09/11/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/">路径总和</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本题为力扣 <strong>437. 路径总和 Ⅲ</strong>：<br>给定一个二叉树的根节点 <code>root</code>，和一个整数 <code>targetSum</code>，求该二叉树里节点值之和等于 <code>targetSum</code> 的路径数目。  </p>
<p>路径 <strong>不需要从根节点开始</strong>，也不需要在叶子节点结束，但必须是 <strong>向下的路径</strong>（从父节点到子节点）。</p>
<hr>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li><p><strong>递归与状态传递</strong><br>在递归类的题目中，几乎都涉及到 <strong>状态的传递</strong>，即当前递归位置所带的信息。  </p>
<ul>
<li>在树里：当前节点是谁？  </li>
<li>在路径题里：当前走到的路径和是多少？  </li>
<li>在组合题里：当前选了哪些数？  </li>
<li>在动态规划里：当前下标、剩余容量、剩余步数？</li>
</ul>
<p>👉 没有这些状态，就无法确定接下来该怎么走。  </p>
<p>在本题中，需要传递的状态是：<strong>经过当前节点后，距离 <code>targetSum</code> 还差多少</strong>。  </p>
<p>同时，递归的返回值也非常重要。通常返回的就是「符合条件的个数」等信息，因为只有返回值才能逐层汇总答案。  </p>
</li>
<li><p><strong>递归结束条件</strong><br>当遍历到空节点时，递归应当结束，返回 0。</p>
</li>
</ol>
<hr>
<h2 id="代码实现（Go）"><a href="#代码实现（Go）" class="headerlink" title="代码实现（Go）"></a>代码实现（Go）</h2><pre><code class="language-go">func pathSum(root *TreeNode, targetSum int) int &#123;
    if root == nil &#123;
        return 0
    &#125;
    return countPath(root, targetSum) + pathSum(root.Left, targetSum) + pathSum(root.Right, targetSum)
&#125;

// 统计以 node 为起点，向下路径和等于 targetSum 的数量
func countPath(node *TreeNode, targetSum int) int &#123;
    if node == nil &#123;
        return 0
    &#125;
    count := 0
    if node.Val == targetSum &#123;
        count++
    &#125;
    count += countPath(node.Left, targetSum-node.Val)
    count += countPath(node.Right, targetSum-node.Val)
    return count
&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/09/11/%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/" data-id="cmfpi7ntj001a4rpvhyn524nl" data-title="路径总和" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPU-CISC-RISC-%E6%8C%87%E4%BB%A4%E9%9B%86-%E6%9E%B6%E6%9E%84/" rel="tag">CPU, CISC, RISC, 指令集, 架构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CPU-%E6%8C%87%E4%BB%A4%E9%9B%86-%E6%B5%81%E6%B0%B4%E7%BA%BF-%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/" rel="tag">CPU, 指令集, 流水线, 分支预测</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFS/" rel="tag">DFS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IPC%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" rel="tag">IPC，进程通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LRU/" rel="tag">LRU</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ai/" rel="tag">ai</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/" rel="tag">事件驱动</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" rel="tag">二分查找</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E6%B1%A0-malloc-%E6%8C%87%E9%92%88/" rel="tag">内存管理, 内存池, malloc, 指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%AA%E6%9E%9D/" rel="tag">剪枝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%8F%E7%A8%8B/" rel="tag">协程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%89%AA%E6%9E%9D/" rel="tag">回溯，剪枝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E8%AE%BA/" rel="tag">图论</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" rel="tag">堆排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85-%E4%BA%92%E6%96%A5%E9%94%81-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E4%BF%A1%E5%8F%B7%E9%87%8F/" rel="tag">多线程, 生产者消费者, 互斥锁, 条件变量, 信号量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/" rel="tag">多线程,同步,异步,阻塞,非阻塞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/" rel="tag">多进程, 进程状态</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" rel="tag">多进程, 进程通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8%E7%BB%84/" rel="tag">容器组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/" rel="tag">容器编排</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" rel="tag">工程实践</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%93%E6%96%87%E4%BB%B6/" rel="tag">库文件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%95%E5%B1%82%E7%BC%96%E8%AF%91/" rel="tag">底层编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" rel="tag">归并排序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8F%90%E6%95%88/" rel="tag">提效</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E5%86%85%E6%A0%B8-IO/" rel="tag">文件描述符, 内核, IO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E6%8A%A5/" rel="tag">日报</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A0%88%E5%8C%BA-%E5%A0%86%E5%8C%BA-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E6%A0%87%E5%87%86%E5%BA%93-%E9%93%BE%E8%A1%A8/" rel="tag">栈区, 堆区, 系统调用, 标准库, 链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" rel="tag">算法总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5-%E4%BA%92%E6%96%A5%E9%94%81-%E8%AF%BB%E5%86%99%E9%94%81/" rel="tag">线程, 同步, 互斥锁, 读写锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B/" rel="tag">线程, 进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E5%90%88/" rel="tag">组合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%88%E7%AB%AF-%E8%BF%9B%E7%A8%8B%E7%BB%84-%E4%BC%9A%E8%AF%9D-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" rel="tag">终端, 进程组, 会话, 守护进程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8Clinux%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" rel="tag">虚拟机，linux，虚拟内存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" rel="tag">语法基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CPU-CISC-RISC-%E6%8C%87%E4%BB%A4%E9%9B%86-%E6%9E%B6%E6%9E%84/" style="font-size: 10px;">CPU, CISC, RISC, 指令集, 架构</a> <a href="/tags/CPU-%E6%8C%87%E4%BB%A4%E9%9B%86-%E6%B5%81%E6%B0%B4%E7%BA%BF-%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B/" style="font-size: 10px;">CPU, 指令集, 流水线, 分支预测</a> <a href="/tags/DFS/" style="font-size: 13.33px;">DFS</a> <a href="/tags/IPC%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" style="font-size: 10px;">IPC，进程通信</a> <a href="/tags/LRU/" style="font-size: 10px;">LRU</a> <a href="/tags/ai/" style="font-size: 10px;">ai</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/golang/" style="font-size: 10px;">golang</a> <a href="/tags/k8s/" style="font-size: 10px;">k8s</a> <a href="/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/" style="font-size: 10px;">事件驱动</a> <a href="/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/" style="font-size: 10px;">二分查找</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 13.33px;">二叉树</a> <a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E5%86%85%E5%AD%98%E6%B1%A0-malloc-%E6%8C%87%E9%92%88/" style="font-size: 10px;">内存管理, 内存池, malloc, 指针</a> <a href="/tags/%E5%88%B7%E9%A2%98/" style="font-size: 20px;">刷题</a> <a href="/tags/%E5%89%AA%E6%9E%9D/" style="font-size: 10px;">剪枝</a> <a href="/tags/%E5%8D%8F%E7%A8%8B/" style="font-size: 10px;">协程</a> <a href="/tags/%E5%9B%9E%E6%BA%AF/" style="font-size: 13.33px;">回溯</a> <a href="/tags/%E5%9B%9E%E6%BA%AF%EF%BC%8C%E5%89%AA%E6%9E%9D/" style="font-size: 10px;">回溯，剪枝</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">图论</a> <a href="/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">堆排序</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85-%E4%BA%92%E6%96%A5%E9%94%81-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-%E4%BF%A1%E5%8F%B7%E9%87%8F/" style="font-size: 10px;">多线程, 生产者消费者, 互斥锁, 条件变量, 信号量</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E/" style="font-size: 10px;">多线程,同步,异步,阻塞,非阻塞</a> <a href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81/" style="font-size: 10px;">多进程, 进程状态</a> <a href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" style="font-size: 10px;">多进程, 进程通信</a> <a href="/tags/%E5%AE%B9%E5%99%A8%E7%BB%84/" style="font-size: 10px;">容器组</a> <a href="/tags/%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92/" style="font-size: 10px;">容器编排</a> <a href="/tags/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/" style="font-size: 10px;">工程实践</a> <a href="/tags/%E5%BA%93%E6%96%87%E4%BB%B6/" style="font-size: 10px;">库文件</a> <a href="/tags/%E5%BA%95%E5%B1%82%E7%BC%96%E8%AF%91/" style="font-size: 10px;">底层编译</a> <a href="/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">归并排序</a> <a href="/tags/%E6%8F%90%E6%95%88/" style="font-size: 10px;">提效</a> <a href="/tags/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E5%86%85%E6%A0%B8-IO/" style="font-size: 10px;">文件描述符, 内核, IO</a> <a href="/tags/%E6%97%A5%E6%8A%A5/" style="font-size: 10px;">日报</a> <a href="/tags/%E6%A0%88%E5%8C%BA-%E5%A0%86%E5%8C%BA-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-%E6%A0%87%E5%87%86%E5%BA%93-%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">栈区, 堆区, 系统调用, 标准库, 链表</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 20px;">算法</a> <a href="/tags/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" style="font-size: 10px;">算法总结</a> <a href="/tags/%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5-%E4%BA%92%E6%96%A5%E9%94%81-%E8%AF%BB%E5%86%99%E9%94%81/" style="font-size: 10px;">线程, 同步, 互斥锁, 读写锁</a> <a href="/tags/%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B/" style="font-size: 10px;">线程, 进程</a> <a href="/tags/%E7%BB%84%E5%90%88/" style="font-size: 10px;">组合</a> <a href="/tags/%E7%BB%88%E7%AB%AF-%E8%BF%9B%E7%A8%8B%E7%BB%84-%E4%BC%9A%E8%AF%9D-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B/" style="font-size: 10px;">终端, 进程组, 会话, 守护进程</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">编程</a> <a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%8Clinux%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/" style="font-size: 10px;">虚拟机，linux，虚拟内存</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">设计模式</a> <a href="/tags/%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">语法基础</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 16.67px;">递归</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/09/">九月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">八月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">三月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">二月 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">一月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/09/25/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/">括号生成</a>
          </li>
        
          <li>
            <a href="/2025/09/24/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/">组合总和</a>
          </li>
        
          <li>
            <a href="/2025/09/23/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/">搜索旋转排序数组</a>
          </li>
        
          <li>
            <a href="/2025/09/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">二叉树的最近公共祖先</a>
          </li>
        
          <li>
            <a href="/2025/09/18/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/">数组中第k个最大元素</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 Fxp<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>